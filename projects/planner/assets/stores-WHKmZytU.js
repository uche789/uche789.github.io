import{H as te,b as se,I as ae,J as re,c as ie,K as N,L as J,M as ye,i as De,w as xe,r as Se,N as Re,O as Pe,P as Te,n as Le,Q as ke}from"./RichEditor-DQzkoqnZ.js";var qe=!1;/*!
 * pinia v2.3.0
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */let ne;const $=e=>ne=e,oe=Symbol();function W(e){return e&&typeof e=="object"&&Object.prototype.toString.call(e)==="[object Object]"&&typeof e.toJSON!="function"}var F;(function(e){e.direct="direct",e.patchObject="patch object",e.patchFunction="patch function"})(F||(F={}));function We(){const e=te(!0),t=e.run(()=>se({}));let a=[],s=[];const r=ae({install(i){$(r),r._a=i,i.provide(oe,r),i.config.globalProperties.$pinia=r,s.forEach(n=>a.push(n)),s=[]},use(i){return!this._a&&!qe?s.push(i):a.push(i),this},_p:a,_a:null,_e:e,_s:new Map,state:t});return r}const ce=()=>{};function Y(e,t,a,s=ce){e.push(t);const r=()=>{const i=e.indexOf(t);i>-1&&(e.splice(i,1),s())};return!a&&Pe()&&Te(r),r}function j(e,...t){e.slice().forEach(a=>{a(...t)})}const Ie=e=>e(),G=Symbol(),U=Symbol();function V(e,t){e instanceof Map&&t instanceof Map?t.forEach((a,s)=>e.set(s,a)):e instanceof Set&&t instanceof Set&&t.forEach(e.add,e);for(const a in t){if(!t.hasOwnProperty(a))continue;const s=t[a],r=e[a];W(r)&&W(s)&&e.hasOwnProperty(a)&&!N(s)&&!J(s)?e[a]=V(r,s):e[a]=s}return e}const je=Symbol();function Ae(e){return!W(e)||!e.hasOwnProperty(je)}const{assign:k}=Object;function Ee(e){return!!(N(e)&&e.effect)}function Me(e,t,a,s){const{state:r,actions:i,getters:n}=t,c=a.state.value[e];let u;function d(){c||(a.state.value[e]=r?r():{});const h=ke(a.state.value[e]);return k(h,i,Object.keys(n||{}).reduce((f,b)=>(f[b]=ae(ie(()=>{$(a);const w=a._s.get(e);return n[b].call(w,w)})),f),{}))}return u=de(e,d,t,a,s,!0),u}function de(e,t,a={},s,r,i){let n;const c=k({actions:{}},a),u={deep:!0};let d,h,f=[],b=[],w;const m=s.state.value[e];!i&&!m&&(s.state.value[e]={}),se({});let T;function q(g){let l;d=h=!1,typeof g=="function"?(g(s.state.value[e]),l={type:F.patchFunction,storeId:e,events:w}):(V(s.state.value[e],g),l={type:F.patchObject,payload:g,storeId:e,events:w});const x=T=Symbol();Le().then(()=>{T===x&&(d=!0)}),h=!0,j(f,l,s.state.value[e])}const _=i?function(){const{state:l}=a,x=l?l():{};this.$patch(I=>{k(I,x)})}:ce;function A(){n.stop(),f=[],b=[],s._s.delete(e)}const D=(g,l="")=>{if(G in g)return g[U]=l,g;const x=function(){$(s);const I=Array.from(arguments),M=[],B=[];function be(S){M.push(S)}function ve(S){B.push(S)}j(b,{args:I,name:x[U],store:P,after:be,onError:ve});let O;try{O=g.apply(this&&this.$id===e?this:P,I)}catch(S){throw j(B,S),S}return O instanceof Promise?O.then(S=>(j(M,S),S)).catch(S=>(j(B,S),Promise.reject(S))):(j(M,O),O)};return x[G]=!0,x[U]=l,x},L={_p:s,$id:e,$onAction:Y.bind(null,b),$patch:q,$reset:_,$subscribe(g,l={}){const x=Y(f,g,l.detached,()=>I()),I=n.run(()=>xe(()=>s.state.value[e],M=>{(l.flush==="sync"?h:d)&&g({storeId:e,type:F.direct,events:w},M)},k({},u,l)));return x},$dispose:A},P=Se(L);s._s.set(e,P);const E=(s._a&&s._a.runWithContext||Ie)(()=>s._e.run(()=>(n=te()).run(()=>t({action:D}))));for(const g in E){const l=E[g];if(N(l)&&!Ee(l)||J(l))i||(m&&Ae(l)&&(N(l)?l.value=m[g]:V(l,m[g])),s.state.value[e][g]=l);else if(typeof l=="function"){const x=D(l,g);E[g]=x,c.actions[g]=l}}return k(P,E),k(re(P),E),Object.defineProperty(P,"$state",{get:()=>s.state.value[e],set:g=>{q(l=>{k(l,g)})}}),s._p.forEach(g=>{k(P,n.run(()=>g({store:P,app:s._a,pinia:s,options:c})))}),m&&i&&a.hydrate&&a.hydrate(P.$state,m),d=!0,h=!0,P}/*! #__NO_SIDE_EFFECTS__ */function le(e,t,a){let s,r;const i=typeof t=="function";typeof e=="string"?(s=e,r=i?a:t):(r=e,s=e.id);function n(c,u){const d=Re();return c=c||(d?De(oe,null):null),c&&$(c),c=ne,c._s.has(s)||(i?de(s,t,r,c):Me(s,r,c)),c._s.get(s)}return n.$id=s,n}function Ve(e){{const t=re(e),a={};for(const s in t){const r=t[s];r.effect?a[s]=ie({get:()=>e[s],set(i){e[s]=i}}):(N(r)||J(r))&&(a[s]=ye(e,s))}return a}}const Je={mon:"Monday",tue:"Tuesday",wed:"Wednesday",thu:"Thursday",fri:"Friday",sat:"Saturday",sun:"Sunday"};var R=(e=>(e[e.Open=1]="Open",e[e.Progress=2]="Progress",e[e.Done=3]="Done",e))(R||{}),Oe=(e=>(e[e.High=1]="High",e[e.Medium=2]="Medium",e[e.Normal=3]="Normal",e[e.Trivial=4]="Trivial",e))(Oe||{});const ze={1:"High",2:"Medium",3:"Normal",4:"Trivial"};var v=(e=>(e.list="list",e.dateRange="dateRange",e.tomorrow="tomorrow",e.today="today",e.upcoming="upcoming",e.habits="habits",e.archived="archived",e))(v||{});const o={Lists:"lists",Tasks:"tasks",Settings:"appSettings",Reports:"reports",TaskRecords:"taskRecords"},Qe=le("tasks",{state:()=>({pageListId:0,lists:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},habits:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},todaysTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},allUpcomingTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},tomorrowsTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},selectedListTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},recentList:[],updatingState:{list:!1,habit:!1,task:!1},currentSelectedTask:null}),getters:{selectedPageList(){return this.lists.data.find(e=>e.id===this.pageListId)},countTodaysTask(){return this.todaysTasks.pagination.total},countList(){return this.lists.pagination.total}},actions:{async getTodaysTasks(e=1,t=!1,a=!1){const r=10*e-10;this.todaysTasks=await this.$api.service.getTodaysList(r,10,t,a)},async getTomorrowTasks(e=1,t=!1){const s=7*e-7;this.tomorrowsTasks=await this.$api.service.getTomorrowsList(s,7,t)},async getUpcoming(e=1,t=!1){const s=20*e-20;this.allUpcomingTasks=await this.$api.service.getUpcoming(s,20,t)},async getAllList(e=1){const a=50*e-50;this.lists=await this.$api.service.getAllList(a,50)},async getCount(){this.getAllList(),this.getTodaysTasks()},async addList(e){return await this.$api.service.addList(e)},async getList(e){let t=this.lists.data.findIndex(a=>a.id===e);if(t===-1){const a=await this.$api.service.getList(e);this.lists.data.push(a),t=this.lists.data.length-1}return this.lists.data[t]},async getTaskForList(e,t=1,a=!1,s=!1){const i=20*t-20;this.selectedListTasks=await this.$api.service.getTaskForList(e,i,20,a,s)},async deleteList(e){await this.$api.service.deleteList(e),this.recentList=this.recentList.filter(t=>t.id!==e)},async updateList(e){const t=this.lists.data.findIndex(a=>a.id===e.id);await this.$api.service.updateList(e),this.lists.data[t]={...this.lists.data[t],...e}},setPageListId(e){this.pageListId=e},async getHabits(e=1,t=!1){const s=20*e-20;this.habits=await this.$api.service.getHabits(s,20,t)},async addTask(e){await this.$api.service.addTask(e)},async updateTask(e){const t=await this.$api.service.updateTask(e);if(e.listId){let a=this.selectedListTasks.data.find(s=>s.id===e.id);if(a){a={...a,...t};return}}},async changeTaskStatus(e,t){const a=()=>t||(!t&&t===R.Open?R.Done:!t&&e.status===R.Done?R.Open:R.Done),s=await this.$api.service.updateTask({id:e.id,status:a(),statusRecordId:e.statusRecordId,statusUpdatedAt:e.statusUpdatedAt},!0);return e.statusRecordId=s.statusRecordId,e.status=s.status,e.statusUpdatedAt=s.statusUpdatedAt,t},async deleteTask(e){await this.$api.service.deleteTask(e)},async getRecentList(){this.recentList=(await this.$api.service.getRecentLists()).data},async setUpdatingState(e,t){this.updatingState[e]=t},async getCurrentlySelectedTast(e){this.currentSelectedTask=await this.$api.service.getTask(e)}}});var C=(e=>(e.isTabletPortrait="isTabletPortrait",e.isTabletLandscape="isTabletLandscape",e.isMobilePortrait="isMobilePortrait",e.isMobileLandscape="isMobileLandscape",e))(C||{});class p extends Error{}class Ce extends Error{}class Ye extends Error{}class Fe extends Error{}const ue={RECORD:"RECORD",TASK:"TASK"};class he extends Error{constructor(t,a,s,r){super(a,s),this.key=t,this.data=r}}const ge=60*60*24*1e3;function z(e){const t=e.getMonth()+1,a=e.getDate();return`${e.getFullYear()}-${t<10?"0"+t:t}-${a<10?"0"+a:a}`}const y=()=>z(new Date),K=()=>z(new Date(Date.now()+ge)),fe=(e,t)=>{const a=t?new Date(t).getTime():Date.now();return z(new Date(a+ge*e))},pe=(e,t={},a)=>(e=e instanceof Date?e:new Date(e),new Intl.DateTimeFormat("en-US",t).format(e)),X=(e,t)=>{const a=new Set;let s=e;for(;s<=t;){const r=pe(s,{weekday:"short"}).toLowerCase();if(a.add(r),s=fe(1,s),a.size===7)break}return a};class Ne{constructor(t){this.indexRequest=t}getAllCount(t="valid"){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").getAll();r.onerror=()=>{s(new p("Failed to retreive list count"))},r.onsuccess=()=>{const i=r.result;t==="valid"&&a(i.filter(n=>t==="valid"&&n.isDeleted!==!1&&n.endDate>=y()).length),t==="archived"&&a(i.filter(n=>t==="archived"&&n.isArchived&&!n.isDeleted).length)}})}getAll(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").openCursor(null,"prev");r.onerror=()=>{s(new Error("Failed to get lists"))};const i={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},n=t.offset||0,c=t.limit||50;let u=0,d=n>0,h=0;r.onsuccess=async f=>{const b=f.target?.result;if(b&&d){d=!1,b.advance(n+1);return}if(b&&!d){t.type==="recent"&&u===4&&a(i);const w=b.value;let m=(w.isArchived||w.endDate>=y())&&!w.isDeleted;m&&t.type==="archived"&&(m=w.isArchived),m=m&&(!t.getOnlyActive||t.getOnlyActive&&w.startDate>y()),m&&(u<c&&(i.data.push(w),u++),h++),b.continue()}else i.pagination.page=n?Math.ceil(h/n):1,i.pagination.total=h,i.pagination.itemsPerPage=c,i.pagination.totalPages=Math.ceil(h/c),a(i)}})}add(t){return new Promise((a,s)=>{const r=Object.assign({},t,{createdDate:Date.now(),lastModifiedDate:Date.now(),isArchived:!1,isDeleted:!1});(!r.endDate||!r.startDate||r.startDate>r.endDate)&&s(new Ce("Start and end dates are required and should be valid"));const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).add(r);i.onerror=()=>{s(new Error("Failed to get lists"))},i.onsuccess=()=>{a({...r,id:i.result})}})}async update(t){const a=Object.assign({},await this.get(t.id),{lastModifiedDate:String(Date.now())},t);return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).put(a);i.onerror=()=>{r(new Error("Failed to update list"))},i.onsuccess=()=>{s(i.result)}})}get(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).get(t);r.onerror=()=>{s(new Error("Failed to get lists"))},r.onsuccess=()=>{a(r.result)}})}remove(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).delete(t);r.onerror=()=>{s(new Error("Failed to remove list"))},r.onsuccess=()=>{a(null)}})}}function Z(e,t){const a=new Set,s=[];for(const r of e)a.add(r);for(const r of t)a.has(r)&&s.push(r);return s}function Ge(e){const a=pe(new Date,{hour12:!1,hour:"numeric",minute:"numeric"});return e>a}const we=e=>e.status===R.Open&&e.carryOver&&e.startDate<y()||!!e.days.length&&(!e.endDate||!!e.endDate&&e.endDate>=y())||!e.days.length&&e.startDate>=y(),H={[v.habits]:e=>!!e.days.length,[v.archived]:e=>e.isArchived,[v.list]:(e,t)=>e.listId===t,[v.today]:e=>{const t=e.status===R.Open&&e.carryOver&&e.startDate<y();return!e.listId&&(t||e.startDate===y()&&!e.days.length||!!e.days.length&&!!Z([...X(y(),y())],e.days).length)},[v.tomorrow]:e=>!e.listId&&(e.startDate===K()||!!e.days.length&&!!Z([...X(K(),K())],e.days).length),[v.upcoming]:e=>!e.listId&&e.startDate>=fe(2),[v.dateRange]:(e,t)=>!e.listId&&(e.startDate>=t.from||e.startDate<=t.to)};class $e{constructor(t){this.indexRequest=t}get(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).get(t);r.onerror=()=>{s(new p("Failed to get task"))},r.onsuccess=()=>{a(r.result)}})}async add(t){const a=Object.assign({},t,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:R.Open});if(a.listId){const s=await this.getListDates(a.listId);a.startDate=s.from,a.endDate=s.to}return new Promise((s,r)=>{a.startDate||(a.startDate=y());const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).add(a);i.onerror=()=>{r(new p("Failed to add new task"))},i.onsuccess=()=>{s({...a,id:i.result})}})}async update(t){const a=Object.assign({},await this.get(t.id),{lastModifiedDate:String(Date.now())},t);if(a.listId){const s=await this.getListDates(a.listId);a.startDate=s.from,a.endDate=s.to}return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).put(a);i.onerror=()=>{r(new Error("Failed to update task"))},i.onsuccess=()=>{s({...a,id:i.result})}})}getListDates(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Lists]).objectStore(o.Lists).get(t);r.onerror=()=>{s(new Error("Failed to get list for task"))},r.onsuccess=()=>{const i=r.result;a({from:i.startDate,to:i.endDate})}})}remove(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).delete(t);r.onerror=()=>{s(new p("Failed to remove task"))},r.onsuccess=()=>{a(null)}})}async getAll(t){let a=t.sortByPriority?"priority":"createdDate",s=t.sortByPriority?"next":"prev";t.sortByCompletion&&(a="status",s="next");const r=[],n=await new Promise((u,d)=>{const h=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index(a).openCursor(null,s);h.onerror=()=>{d(new p("Failed to get tasks"))};const f={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let b=0;const w=t.offset||0,m=t.limit||50;let T=0,q=w;h.onsuccess=_=>{const A=_.target?.result;if(A){const D=A.value;let L=!!D.listId||D.isArchived||we(D);L&&(t.type===v.dateRange?L=H.dateRange(D,t.dateRange||{from:"",to:""}):t.type===v.list?L=H.list(D,t.listId||0):L=H[t.type](D)),L&&q>0?(T++,q--,r.push(D.id)):L&&q===0&&(b<m&&(f.data.push(D),b++),r.push(D.id),T++),A.continue()}else f.pagination.page=w?Math.ceil(T/w):1,f.pagination.total=T,f.pagination.itemsPerPage=m,f.pagination.totalPages=Math.ceil(T/m),u(f)}}),c=await this.getAllTaskRecords(t.type,n.data,r.sort((u,d)=>u-d),t.activeList);return n.data=c.result,n.pagination.completed=c.completed,n}async getAllTaskRecords(t,a,s,r=!1){if(!a.length||![v.today,v.list].includes(t)||v.list===t&&!r)return{result:a,completed:0};const n=await new Promise((d,h)=>{const f=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("taskId").getAll(IDBKeyRange.upperBound(s[s.length-1]));f.onerror=()=>{h(new Error("Failed to add task record"))},f.onsuccess=()=>{d(f.result)}});let c=0;return{result:a.map(d=>{let h;return t===v.today?h=n.find(f=>f.taskId===d.id&&f.timestamp===y()):t===v.list&&(h=n.find(f=>f.taskId===d.id&&!!d.listId)),h?(d.status=h.status,d.statusUpdatedAt=h.timestamp,d.statusRecordId=h.id,h.status===R.Done&&c++):(d.status=R.Open,d.statusUpdatedAt=void 0,d.statusRecordId=void 0),d}),completed:c}}updateTaskRecord(t){if(!t.id)return delete t.id,t.timestamp||(t.timestamp=y()),new Promise((a,s)=>{try{const r=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).add(t);r.onerror=()=>{s(new Error("Failed to add task record"))},r.onsuccess=()=>{a({...t,id:r.result})}}catch(r){throw console.error(r),r}});if(!t.timestamp)throw new p("invalid timestamp");return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).put(t);r.onerror=()=>{s(new Error("Failed to update task record"))},r.onsuccess=()=>{a(t)}})}getAllByListId(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),i=[];r.onerror=()=>{s(new p(`Failed to tasks for id ${t}`))},r.onsuccess=n=>{const c=n.target.result;c?(c.value.listId===t&&i.push(c.value),c.continue()):a(i)}})}async removeTasksByListId(t){let a=!1;const s=[];try{const r=await this.getAllByListId(t);for(const i of r)try{await this.remove(i.id),s.push(i.id)}catch{a=!0}a&&new he(ue.TASK,"Failed to remove some tasks from the list",{},s)}catch{}return s}updateAllTasksForList(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),i=[];r.onerror=()=>{s(new p("Failed to update tasks for list"))},r.onsuccess=n=>{const c=n.target.result;if(c){const u=c.value;if(u.listId===t.id){i.push(c.value);const d={};t.endDate&&(d.endDate=t.endDate),t.startDate&&(d.startDate=t.endDate),c.update({...u,...d})}c.continue()}else a(null)}})}}class _e{constructor(t){this.indexRequest=t}add(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Reports],"readwrite").objectStore(o.Reports).add(t);r.onerror=()=>{if(r.error?.message.includes("constraint")||r.error?.message==="Key already exists in the object store."){s(new Fe(r.error?.message));return}s(new p("Failed to add new report"))},r.onsuccess=()=>{a(t)}})}async get(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Reports]).objectStore(o.Reports).get(t);r.onerror=()=>{s(new p("Failed to get report"))},r.onsuccess=()=>{a(r.result)}})}}class me{constructor(t){this.indexRequest=t,this.objectNames=o}objectNames}class Be extends me{get(){return new Promise((t,a)=>{const s=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();s.onerror=()=>{a(new p("Error retrieving settings"))},s.onsuccess=()=>{t(s.result[0])}})}add(t){return new Promise((a,s)=>{t.lastModifiedDate=Date.now();const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(t);r.onerror=()=>{s(new p("Error saving settings"))},r.onsuccess=()=>{a({...t,id:r.result})}})}update(t){return new Promise((a,s)=>{t.lastModifiedDate=Date.now();const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(t);r.onerror=()=>{s(new p("Error saving settings"))},r.onsuccess=()=>{a(t)}})}}class Ue extends me{async cleanupLists(){let t=!0,a=0;const s=await this.getAllInvalidLists();try{for(const r of s)try{a+=await this.cleanupTasks(r)}catch{t=!0}t&&new he(ue.TASK,"Failed to remove some tasks from the list",{})}catch{}return t||await this.deleteLists(s),{deletedLists:s.length,deletedTasks:a}}deleteLists(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction(this.objectNames.Lists,"readwrite").objectStore(this.objectNames.Lists).delete(t);r.onerror=()=>{s(new p("Failed to clean up old list"))},r.onsuccess=()=>{a(r.result)}})}async cleanupTasks(t){const a=await this.getAllInvalidTasks(t);return new Promise((s,r)=>{const i=this.indexRequest.result.transaction(this.objectNames.Tasks,"readwrite").objectStore(this.objectNames.Tasks).delete(a);i.onerror=()=>{r(new p("Error retrieving settings"))},i.onsuccess=()=>{s(a.length)}})}getAllInvalidTasks(t){return new Promise((a,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).index("createdDate").openCursor();r.onerror=()=>{s(new Error("Failed to get invalid tasks"))};const i=[];r.onsuccess=n=>{const c=n.target?.result;if(c){const u=c.value;(t&&t===u.listId||!t&&!u.listId&&!we(u)&&!u.isArchived)&&i.push(u),c.continue()}else a(i.map(u=>u.id))}})}getAllInvalidLists(){return new Promise((t,a)=>{const s=this.indexRequest.result.transaction([o.Lists],"readonly").objectStore(o.Lists).index("createdDate").openCursor();s.onerror=()=>{a(new Error("Failed to get lists"))};const r=[];s.onsuccess=i=>{const n=i.target?.result;if(n){const c=n.value;(c.isDeleted||c.endDate<y()&&!c.isArchived)&&r.push(n.value),n.continue()}else t(r.map(c=>c.id))}})}}class Q{tasks;lists;indexRequest;reports;cleanup;settings;static instance;async hasDatabase(){return new Promise((t,a)=>{if(!this.indexRequest){a(new p("Database does not exist"));return}try{const s=this.indexRequest.result.transaction([o.Settings]).objectStore(o.Settings).getAll();s.onerror=()=>{a(new p("Error retrieving settings"))},s.onsuccess=()=>{t(!!s.result.length)}}catch(s){if(s.message.includes("The database connection is closing")){t(!1);return}a(new p(s.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((t,a)=>{const s=indexedDB.open("personalPlanner",13);s.onerror=()=>{a(new p("Cannot use IndexDB"))},s.onsuccess=()=>{const r=s.result;r.onerror=i=>{a(new p(`Database error: ${i.target?.errorCode}`))},this.indexRequest=s,t(s)},s.onupgradeneeded=r=>{const i=s.result;if(!i.objectStoreNames.contains(o.Lists)){const n=i.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});n.createIndex("description","description"),n.createIndex("createdDate","createdDate"),n.createIndex("lastModifiedDate","lastModifiedDate"),n.createIndex("startDate","startDate"),n.createIndex("endDate","endDate"),n.createIndex("isDeleted","isDeleted"),n.createIndex("isArchived","isArchived")}if(!i.objectStoreNames.contains(o.TaskRecords)){const n=i.createObjectStore(o.TaskRecords,{autoIncrement:!0,keyPath:"id"});n.createIndex("taskId","taskId"),n.createIndex("status","status"),n.createIndex("timestamp","timestamp")}if(r.oldVersion,i.objectStoreNames.contains(o.Reports)||i.createObjectStore(o.Reports,{keyPath:"date"}).createIndex("count","count"),!i.objectStoreNames.contains(o.Settings)){const n=i.createObjectStore(o.Settings,{keyPath:"id",autoIncrement:!0});n.createIndex("archive","archive"),n.createIndex("archiveFor","archiveFor"),n.createIndex("image","image"),n.createIndex("name","name"),n.createIndex("lastModifiedDate","lastModifiedDate"),n.createIndex("theme","theme")}if(!i.objectStoreNames.contains(o.Tasks)){const n=i.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"});n.createIndex("listId","listId"),n.createIndex("description","description"),n.createIndex("note","note"),n.createIndex("startTime","startTime"),n.createIndex("endTime","endTime"),n.createIndex("priority","priority"),n.createIndex("status","status"),n.createIndex("days","days"),n.createIndex("carryOver","carryOver"),n.createIndex("createdDate","createdDate"),n.createIndex("lastModifiedDate","lastModifiedDate"),n.createIndex("startDate","startDate"),n.createIndex("endDate","endDate"),n.createIndex("isDeleted","isDeleted"),n.createIndex("isArchived","isArchived")}}})}repositories(){if(!this.indexRequest)throw new p;return{tasks:this.tasks||new $e(this.indexRequest),cleanup:this.cleanup||new Ue(this.indexRequest),lists:this.lists||new Ne(this.indexRequest),reports:this.reports||new _e(this.indexRequest),settings:this.settings||new Be(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new Q,await this.instance.start()),this.instance}async clear(t){this.indexRequest&&this.indexRequest.result.transaction([t],"readwrite").objectStore(t).clear()}async delete(){return new Promise((t,a)=>{this.indexRequest?.result.close();const s=indexedDB.deleteDatabase("personalPlanner");s.onerror=()=>{a(new p("Error deleting database."))},s.onsuccess=()=>{this.indexRequest=void 0,t(null)},s.onblocked=()=>{a(new p("Request is blocked"))}})}}const ee={id:0,name:"",archive:!1,archiveFor:30,theme:"default"},Xe=le("appStore",{state:()=>({isMobileLandscape:!1,isMobilePortrait:!1,isTabletLandscape:!1,isTabletPortrait:!1,device:{[C.isTabletPortrait]:!1,[C.isTabletLandscape]:!1,[C.isMobilePortrait]:!1,[C.isMobileLandscape]:!1},settings:ee,globalLoading:!1}),getters:{isTablet(){return this.device.isTabletLandscape||this.device.isTabletPortrait},isMobile(){return this.device.isMobileLandscape||this.device.isMobilePortrait}},actions:{setMediaMatch(e,t){this.device[e]=t},async getSettings(e=!1){!e&&this.settings.id!==0||(this.settings=await this.$api.service.getSettings())},async updateSettings(e){this.settings=await this.$api.service.updateSettings(e),this.getSettings(!0)},async deleteApp(){return this.settings=ee,(await Q.getInstance()).delete()},async addSettings(e){this.settings=await this.$api.service.addSettings(e)},setGlobalLoading(e){this.globalLoading=e}}}),Ze=({app:e})=>({$api:e.config.globalProperties.$api});export{C as D,v as F,Q as L,Ye as N,Oe as P,R as T,Qe as a,y as b,K as c,Je as d,We as e,pe as f,z as g,Ze as h,Ge as o,ze as p,Ve as s,Xe as u};
