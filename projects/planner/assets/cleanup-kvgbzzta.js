(function(){"use strict";function R(a){const e=a.getUTCMonth()+1,t=a.getUTCDate();return`${a.getUTCFullYear()}-${e<10?"0"+e:e}-${t<10?"0"+t:t}`}const p=()=>R(new Date),N=a=>(a=typeof a=="string"?new Date(a):a,{from:R(new Date(a.getUTCFullYear(),a.getUTCMonth(),1)),to:R(new Date(a.getUTCFullYear(),a.getUTCMonth()+1,0))}),k=()=>R(new Date(Date.now()+864e5)),B=(a,e)=>{const t=e?new Date(e).getTime():Date.now();return R(new Date(t+864e5*a))},M=(a,e={},t)=>(a=a instanceof Date?a:new Date(a),new Intl.DateTimeFormat("en-US",{...e,timeZone:"UTC"}).format(a)),I=(a,e)=>{const t=new Set;let r=a;for(;r<=e;){const s=M(r,{weekday:"short"}).toLowerCase();if(t.add(s),r=B(1,r),t.size===7)break}return t};function A(a,e){const t=new Set,r=[];for(const s of a)t.add(s);for(const s of e)t.has(s)&&r.push(s);return r}function j(a,e){const t=JSON.stringify(a),r=new Blob([t],{type:"application/json"}),s=URL.createObjectURL(r),n=document.createElement("a");n.href=s,n.download=e,document.body.appendChild(n),n.click(),document.body.removeChild(n),URL.revokeObjectURL(s)}var b=(a=>(a[a.Open=1]="Open",a[a.Progress=2]="Progress",a[a.Done=3]="Done",a))(b||{}),h=(a=>(a.list="list",a.dateRange="dateRange",a.tomorrow="tomorrow",a.today="today",a.upcoming="upcoming",a.habits="habits",a.archived="archived",a))(h||{});const o={Lists:"lists",Tasks:"tasks",Settings:"appSettings",Reports:"reports",TaskRecords:"taskRecords"};class U{constructor(e){this.db=e}async deleteList(e){await this.db.lists.remove(e),await this.db.tasks.removeTasksByListId(e)}async getList(e){return await this.db.lists.get(e)}async getAllList(e,t){return await this.db.lists.getAll({type:"valid",offset:e,limit:t})}async getTaskForList(e,t,r,s=!1,n=!1){return await this.db.tasks.getAll({type:h.list,listId:e,offset:t,limit:r,sortByPriority:s,sortByCompletion:n})}async getHabits(e,t,r=!1){return await this.db.tasks.getAll({type:h.habits,offset:e,limit:t,sortByPriority:r})}async getHabitRecords(e){return await this.db.tasks.getHabitRecords(e)}async getTask(e){return await this.db.tasks.get(e)}async getTodaysList(e,t,r=!1,s=!1){return await this.db.tasks.getAll({type:h.today,offset:e,limit:t,sortByPriority:r,sortByCompletion:s})}async getTomorrowsList(e,t,r=!1){return await this.db.tasks.getAll({type:h.tomorrow,offset:e,limit:t,sortByPriority:r})}async getUpcoming(e,t,r=!1){return await this.db.tasks.getAll({type:h.upcoming,offset:e,limit:t,sortByPriority:r})}async deleteTask(e){await this.db.tasks.remove(e)}async updateTask(e,t=!1){if(t){const r=await this.db.tasks.updateTaskRecord({id:e.statusRecordId,status:e.status||b.Open,taskId:e.id,timestamp:e.statusUpdatedAt});return await this.db.tasks.update({...e,statusRecordId:r.id,statusUpdatedAt:r.timestamp})}return await this.db.tasks.update(e)}async updateList(e){await this.db.lists.update(e),await this.db.tasks.updateAllTasksForList(e)}getRecentLists(){return this.db.lists.getAll({type:"recent"})}async addTask(e){return await this.db.tasks.add(e)}async addList(e){return await this.db.lists.add(e)}cleanOldRecords(){return Promise.all([this.db.cleanup.cleanupLists(),this.db.cleanup.cleanupTasks()])}async getSettings(){return await this.db.settings.get()}async updateSettings(e){const r={...await this.getSettings(),...e};return await this.db.settings.update(r)}async addSettings(e){return await this.db.settings.add(e)}async downloadContent(e){if(e==="habits"){const t=await this.db.tasks.getAll({type:h.habits,offset:0,limit:1e4});j(t.data,"habits.json")}else{const t=await this.db.lists.getAll({type:"valid",offset:0,limit:1e4}),r=[];for(const s of t.data){const n=(await this.db.tasks.getAll({type:h.list,listId:s.id,offset:0,limit:1e4})).data;r.push({...s,data:n})}j(r,"lists_and_tasks.json")}}async importContent(e,t){if(e==="habits"){const s=[];for(const n of t){const i={description:n.description,note:n.note,priority:n.priority,carryOver:n.carryOver,days:JSON.parse(JSON.stringify(n.days)),isArchived:n.isArchived||!1,startDate:n.startDate,order:n.order??0};s.push(this.db.tasks.add(i))}await Promise.all(s);return}const r=[];for(const s of t){const n={description:s.description,startDate:s.startDate,endDate:s.endDate},i=await this.db.lists.add(n);for(const c of s.data){const u={description:c.description,note:c.note,priority:c.priority,carryOver:c.carryOver,days:JSON.parse(JSON.stringify(c.days)),isArchived:c.isArchived||!1,startDate:c.startDate,order:c.order??0,listId:i.id};r.push(this.db.tasks.add(u))}}await Promise.all(r)}}class l extends Error{}class K extends Error{}class J extends Error{}const L={RECORD:"RECORD",TASK:"TASK"};class O extends Error{constructor(e,t,r,s){super(t,r),this.key=e,this.data=s}}class ${constructor(e){this.indexRequest=e}getAllCount(e="valid"){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").getAll();s.onerror=()=>{r(new l("Failed to retreive list count"))},s.onsuccess=()=>{const n=s.result;e==="valid"&&t(n.filter(i=>e==="valid"&&i.isDeleted!==!1&&i.endDate>=p()).length),e==="archived"&&t(n.filter(i=>e==="archived"&&i.isArchived&&!i.isDeleted).length)}})}getAll(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").openCursor(null,"prev");s.onerror=()=>{r(new Error("Failed to get lists"))};const n={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},i=e.offset||0,c=e.limit||50;let u=0,d=i>0,g=0;s.onsuccess=async w=>{const D=w.target?.result;if(D&&d){d=!1,D.advance(i+1);return}if(D&&!d){e.type==="recent"&&u===4&&t(n);const f=D.value;let y=(f.isArchived||f.endDate>=p())&&!f.isDeleted;y&&e.type==="archived"&&(y=f.isArchived),y=y&&(!e.getOnlyActive||e.getOnlyActive&&f.startDate>p()),y&&(u<c&&(n.data.push(f),u++),g++),D.continue()}else n.pagination.page=i?Math.ceil(g/i):1,n.pagination.total=g,n.pagination.itemsPerPage=c,n.pagination.totalPages=Math.ceil(g/c),t(n)}})}add(e){return new Promise((t,r)=>{const s=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),isArchived:!1,isDeleted:!1});(!s.endDate||!s.startDate||s.startDate>s.endDate)&&r(new K("Start and end dates are required and should be valid"));const n=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).add(s);n.onerror=()=>{r(new Error("Failed to get lists"))},n.onsuccess=()=>{t({...s,id:n.result})}})}async update(e){const t=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);return new Promise((r,s)=>{const n=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).put(t);n.onerror=()=>{s(new Error("Failed to update list"))},n.onsuccess=()=>{r(n.result)}})}get(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).get(e);s.onerror=()=>{r(new Error("Failed to get lists"))},s.onsuccess=()=>{t(s.result)}})}remove(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).delete(e);s.onerror=()=>{r(new Error("Failed to remove list"))},s.onsuccess=()=>{t(null)}})}}const C=a=>a.status===b.Open&&a.carryOver&&a.startDate<p()||!!a.days.length&&(!a.endDate||!!a.endDate&&a.endDate>=p())||!a.days.length&&a.startDate>=p(),q={[h.habits]:a=>!!a.days.length,[h.archived]:a=>a.isArchived,[h.list]:(a,e)=>a.listId===e,[h.today]:a=>{const e=a.status===b.Open&&a.carryOver&&a.startDate<p();return!a.listId&&(e||a.startDate===p()&&!a.days.length||!!a.days.length&&!!A([...I(p(),p())],a.days).length)},[h.tomorrow]:a=>!a.listId&&(a.startDate===k()||!!a.days.length&&!!A([...I(k(),k())],a.days).length),[h.upcoming]:a=>!a.listId&&a.startDate>=k()&&!a.days.length,[h.dateRange]:(a,e)=>!a.listId&&(a.startDate>=e.from||a.startDate<=e.to)};class H{constructor(e){this.indexRequest=e}getHabitRecords(e,t){return new Promise((r,s)=>{const n=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("timestamp").openCursor(null,"prev"),i=t||N(new Date),c=[];n.onerror=()=>{s(new l("Failed to get habit records"))},n.onsuccess=u=>{const d=u.target?.result;if(d){const g=d.value;g.taskId===e&&g.timestamp&&g.timestamp>=i.from&&g.timestamp<=i.to&&c.push(g),d.continue()}else r(c)}})}get(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).get(e);s.onerror=()=>{r(new l("Failed to get task"))},s.onsuccess=()=>{t(s.result)}})}async add(e){const t=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:b.Open});if(t.listId){const r=await this.getListDates(t.listId);t.startDate=r.from,t.endDate=r.to}return new Promise((r,s)=>{t.startDate||(t.startDate=p());const n=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).add(t);n.onerror=()=>{s(new l("Failed to add new task"))},n.onsuccess=()=>{r({...t,id:n.result})}})}async update(e){const t=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);if(t.listId){const r=await this.getListDates(t.listId);t.startDate=r.from,t.endDate=r.to}return new Promise((r,s)=>{const n=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).put(t);n.onerror=()=>{s(new Error("Failed to update task"))},n.onsuccess=()=>{r({...t,id:n.result})}})}getListDates(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Lists]).objectStore(o.Lists).get(e);s.onerror=()=>{r(new Error("Failed to get list for task"))},s.onsuccess=()=>{const n=s.result;t({from:n.startDate,to:n.endDate})}})}remove(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).delete(e);s.onerror=()=>{r(new l("Failed to remove task"))},s.onsuccess=()=>{t(null)}})}async getAll(e){let t=e.sortByPriority?"priority":"createdDate",r=e.sortByPriority?"next":"prev";e.type===h.upcoming&&!e.sortByPriority&&(t="startDate",r="next");const s=[],i=await new Promise((u,d)=>{const g=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index(t).openCursor(null,r);g.onerror=()=>{d(new l("Failed to get tasks"))};const w={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let D=0;const f=e.offset||0,y=e.limit||50;let v=0,T=f;g.onsuccess=Z=>{const P=Z.target?.result;if(P){const m=P.value;let x=!!m.listId||m.isArchived||C(m);x&&(e.type===h.dateRange?x=q.dateRange(m,e.dateRange||{from:"",to:""}):e.type===h.list?x=q.list(m,e.listId||0):x=q[e.type](m)),x&&T>0?(v++,T--,s.push(m.id)):x&&T===0&&(D<y&&(w.data.push(m),D++),s.push(m.id),v++),P.continue()}else w.pagination.page=f?Math.ceil(v/f):1,w.pagination.total=v,w.pagination.itemsPerPage=y,w.pagination.totalPages=Math.ceil(v/y),u(w)}}),c=await this.getAllTaskRecords(e.type,i.data,s.sort((u,d)=>u-d),e.activeList);return i.data=c.result,i.pagination.completed=c.completed,i}async getAllTaskRecords(e,t,r,s=!1){if(!t.length||![h.today,h.list].includes(e)||h.list===e&&!s)return{result:t,completed:0};const i=await new Promise((d,g)=>{const w=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("taskId").getAll(IDBKeyRange.upperBound(r[r.length-1]));w.onerror=()=>{g(new Error("Failed to add task record"))},w.onsuccess=()=>{d(w.result)}});let c=0;return{result:t.map(d=>{let g;return e===h.today?g=i.find(w=>w.taskId===d.id&&w.timestamp===p()):e===h.list&&(g=i.find(w=>w.taskId===d.id&&!!d.listId)),g?(d.status=g.status,d.statusUpdatedAt=g.timestamp,d.statusRecordId=g.id,g.status===b.Done&&c++):(d.status=b.Open,d.statusUpdatedAt=void 0,d.statusRecordId=void 0),d}),completed:c}}updateTaskRecord(e){if(!e.id)return delete e.id,e.timestamp||(e.timestamp=p()),new Promise((t,r)=>{try{const s=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).add(e);s.onerror=()=>{r(new Error("Failed to add task record"))},s.onsuccess=()=>{t({...e,id:s.result})}}catch(s){throw console.error(s),s}});if(!e.timestamp)throw new l("invalid timestamp");return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).put(e);s.onerror=()=>{r(new Error("Failed to update task record"))},s.onsuccess=()=>{t(e)}})}getAllByListId(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),n=[];s.onerror=()=>{r(new l(`Failed to tasks for id ${e}`))},s.onsuccess=i=>{const c=i.target.result;c?(c.value.listId===e&&n.push(c.value),c.continue()):t(n)}})}async removeTasksByListId(e){let t=!1;const r=[];try{const s=await this.getAllByListId(e);for(const n of s)try{await this.remove(n.id),r.push(n.id)}catch{t=!0}t&&new O(L.TASK,"Failed to remove some tasks from the list",{},r)}catch{}return r}updateAllTasksForList(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),n=[];s.onerror=()=>{r(new l("Failed to update tasks for list"))},s.onsuccess=i=>{const c=i.target.result;if(c){const u=c.value;if(u.listId===e.id){n.push(c.value);const d={};e.endDate&&(d.endDate=e.endDate),e.startDate&&(d.startDate=e.endDate),c.update({...u,...d})}c.continue()}else t(null)}})}}class V{constructor(e){this.indexRequest=e}add(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Reports],"readwrite").objectStore(o.Reports).add(e);s.onerror=()=>{if(s.error?.message.includes("constraint")||s.error?.message==="Key already exists in the object store."){r(new J(s.error?.message));return}r(new l("Failed to add new report"))},s.onsuccess=()=>{t(e)}})}async get(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Reports]).objectStore(o.Reports).get(e);s.onerror=()=>{r(new l("Failed to get report"))},s.onsuccess=()=>{t(s.result)}})}}class E{constructor(e){this.indexRequest=e,this.objectNames=o}objectNames}class Y extends E{get(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();r.onerror=()=>{t(new l("Error retrieving settings"))},r.onsuccess=()=>{e(r.result[0])}})}add(e){return new Promise((t,r)=>{e.lastModifiedDate=Date.now();const s=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(e);s.onerror=()=>{r(new l("Error saving settings"))},s.onsuccess=()=>{t({...e,id:s.result})}})}update(e){return new Promise((t,r)=>{e.lastModifiedDate=Date.now();const s=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(e);s.onerror=()=>{r(new l("Error saving settings"))},s.onsuccess=()=>{t(e)}})}}class _ extends E{async cleanupLists(){let e=!0,t=0;const r=await this.getAllInvalidLists();try{for(const s of r)try{t+=await this.cleanupTasks(s)}catch{e=!0}e&&new O(L.TASK,"Failed to remove some tasks from the list",{})}catch{}return e||await this.deleteLists(r),{deletedLists:r.length,deletedTasks:t}}deleteLists(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction(this.objectNames.Lists,"readwrite").objectStore(this.objectNames.Lists).delete(e);s.onerror=()=>{r(new l("Failed to clean up old list"))},s.onsuccess=()=>{t(s.result)}})}async cleanupTasks(e){const t=await this.getAllInvalidTasks(e);return new Promise((r,s)=>{const n=this.indexRequest.result.transaction(this.objectNames.Tasks,"readwrite").objectStore(this.objectNames.Tasks).delete(t);n.onerror=()=>{s(new l("Error retrieving settings"))},n.onsuccess=()=>{r(t.length)}})}getAllInvalidTasks(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).index("createdDate").openCursor();s.onerror=()=>{r(new Error("Failed to get invalid tasks"))};const n=[];s.onsuccess=i=>{const c=i.target?.result;if(c){const u=c.value;(e&&e===u.listId||!e&&!u.listId&&!C(u)&&!u.isArchived)&&n.push(u),c.continue()}else t(n.map(u=>u.id))}})}getAllInvalidLists(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readonly").objectStore(o.Lists).index("createdDate").openCursor();r.onerror=()=>{t(new Error("Failed to get lists"))};const s=[];r.onsuccess=n=>{const i=n.target?.result;if(i){const c=i.value;(c.isDeleted||c.endDate<p()&&!c.isArchived)&&s.push(i.value),i.continue()}else e(s.map(c=>c.id))}})}}const z=14,F=12;class S{tasks;lists;indexRequest;reports;cleanup;settings;static instance;async hasDatabase(){return new Promise((e,t)=>{if(!this.indexRequest){t(new l("Database does not exist"));return}try{const r=this.indexRequest.result.transaction([o.Settings]).objectStore(o.Settings).getAll();r.onerror=()=>{t(new l("Error retrieving settings"))},r.onsuccess=()=>{e(!!r.result.length)}}catch(r){if(r.message.includes("The database connection is closing")){e(!1);return}t(new l(r.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((e,t)=>{const r=indexedDB.open("personalPlanner",z);r.onerror=()=>{t(new l("Cannot use IndexDB"))},r.onsuccess=()=>{const s=r.result;s.onerror=n=>{t(new l(`Database error: ${n.target?.errorCode}`))},this.indexRequest=r,e(r)},r.onupgradeneeded=s=>{const n=r.result;if(!n.objectStoreNames.contains(o.Lists)){const i=n.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});i.createIndex("description","description"),i.createIndex("createdDate","createdDate"),i.createIndex("lastModifiedDate","lastModifiedDate"),i.createIndex("startDate","startDate"),i.createIndex("endDate","endDate"),i.createIndex("isDeleted","isDeleted"),i.createIndex("isArchived","isArchived"),i.createIndex("type","type"),i.createIndex("budget","budget")}if(!n.objectStoreNames.contains(o.TaskRecords)){const i=n.createObjectStore(o.TaskRecords,{autoIncrement:!0,keyPath:"id"});i.createIndex("taskId","taskId"),i.createIndex("status","status"),i.createIndex("timestamp","timestamp")}if(n.objectStoreNames.contains(o.Reports)||n.createObjectStore(o.Reports,{keyPath:"date"}).createIndex("count","count"),!n.objectStoreNames.contains(o.Settings)){const i=n.createObjectStore(o.Settings,{keyPath:"id",autoIncrement:!0});i.createIndex("archive","archive"),i.createIndex("archiveFor","archiveFor"),i.createIndex("image","image"),i.createIndex("name","name"),i.createIndex("lastModifiedDate","lastModifiedDate"),i.createIndex("theme","theme")}if(!n.objectStoreNames.contains(o.Tasks)){const i=n.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"});i.createIndex("listId","listId"),i.createIndex("description","description"),i.createIndex("note","note"),i.createIndex("startTime","startTime"),i.createIndex("endTime","endTime"),i.createIndex("priority","priority"),i.createIndex("status","status"),i.createIndex("days","days"),i.createIndex("carryOver","carryOver"),i.createIndex("createdDate","createdDate"),i.createIndex("lastModifiedDate","lastModifiedDate"),i.createIndex("startDate","startDate"),i.createIndex("endDate","endDate"),i.createIndex("isDeleted","isDeleted"),i.createIndex("isArchived","isArchived"),i.createIndex("amount","amount")}if(s.oldVersion===F){if(console.info(`Upgrading from version ${F}.`),n.objectStoreNames.contains(o.Lists)){const i=n.transaction([o.Lists],"readwrite").objectStore(o.Lists);i.createIndex("type","type"),i.createIndex("budget","budget")}n.objectStoreNames.contains(o.Tasks)&&n.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).createIndex("amount","amount")}}})}repositories(){if(!this.indexRequest)throw new l;return{tasks:this.tasks||new H(this.indexRequest),cleanup:this.cleanup||new _(this.indexRequest),lists:this.lists||new $(this.indexRequest),reports:this.reports||new V(this.indexRequest),settings:this.settings||new Y(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new S,await this.instance.start()),this.instance}async clear(e){this.indexRequest&&this.indexRequest.result.transaction([e],"readwrite").objectStore(e).clear()}async delete(){return new Promise((e,t)=>{this.indexRequest?.result.close();const r=indexedDB.deleteDatabase("personalPlanner");r.onerror=()=>{t(new l("Error deleting database."))},r.onsuccess=()=>{this.indexRequest=void 0,e(null)},r.onblocked=()=>{t(new l("Request is blocked"))}})}}onmessage=async function(a){console.info(a.data);const e=await S.getInstance();try{await new U(e.repositories()).cleanOldRecords(),this.postMessage("clean up completed")}catch{}}})();
