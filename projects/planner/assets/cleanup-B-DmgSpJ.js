(function(){"use strict";var b=(n=>(n[n.Open=1]="Open",n[n.Progress=2]="Progress",n[n.Done=3]="Done",n))(b||{}),h=(n=>(n.list="list",n.dateRange="dateRange",n.tomorrow="tomorrow",n.today="today",n.upcoming="upcoming",n.habits="habits",n.archived="archived",n))(h||{});const o={Lists:"lists",Tasks:"tasks",Settings:"appSettings",Reports:"reports",TaskRecords:"taskRecords"};class E{constructor(e){this.db=e}async deleteList(e){await this.db.lists.remove(e),await this.db.tasks.removeTasksByListId(e)}async getList(e){return await this.db.lists.get(e)}async getAllList(e,t){return await this.db.lists.getAll({type:"valid",offset:e,limit:t})}async getTaskForList(e,t,s,r=!1,i=!1){return await this.db.tasks.getAll({type:h.list,listId:e,offset:t,limit:s,sortByPriority:r,sortByCompletion:i})}async getHabits(e,t,s=!1){return await this.db.tasks.getAll({type:h.habits,offset:e,limit:t,sortByPriority:s})}async getHabitRecords(e){return await this.db.tasks.getHabitRecords(e)}async getTask(e){return await this.db.tasks.get(e)}async getTodaysList(e,t,s=!1,r=!1){return await this.db.tasks.getAll({type:h.today,offset:e,limit:t,sortByPriority:s,sortByCompletion:r})}async getTomorrowsList(e,t,s=!1){return await this.db.tasks.getAll({type:h.tomorrow,offset:e,limit:t,sortByPriority:s})}async getUpcoming(e,t,s=!1){return await this.db.tasks.getAll({type:h.upcoming,offset:e,limit:t,sortByPriority:s})}async deleteTask(e){await this.db.tasks.remove(e)}async updateTask(e,t=!1){if(t){const s=await this.db.tasks.updateTaskRecord({id:e.statusRecordId,status:e.status||b.Open,taskId:e.id,timestamp:e.statusUpdatedAt});return await this.db.tasks.update({...e,statusRecordId:s.id,statusUpdatedAt:s.timestamp})}return await this.db.tasks.update(e)}async updateList(e){await this.db.lists.update(e),await this.db.tasks.updateAllTasksForList(e)}getRecentLists(){return this.db.lists.getAll({type:"recent"})}async addTask(e){return await this.db.tasks.add(e)}async addList(e){return await this.db.lists.add(e)}cleanOldRecords(){return Promise.all([this.db.cleanup.cleanupLists(),this.db.cleanup.cleanupTasks()])}async getSettings(){return await this.db.settings.get()}async updateSettings(e){const s={...await this.getSettings(),...e};return await this.db.settings.update(s)}async addSettings(e){return await this.db.settings.add(e)}}class l extends Error{}class M extends Error{}class B extends Error{}const I={RECORD:"RECORD",TASK:"TASK"};class j extends Error{constructor(e,t,s,r){super(t,s),this.key=e,this.data=r}}const L=3600*24*1e3;function R(n){const e=n.getUTCMonth()+1,t=n.getUTCDate();return`${n.getUTCFullYear()}-${e<10?"0"+e:e}-${t<10?"0"+t:t}`}const p=()=>R(new Date),N=n=>(n=typeof n=="string"?new Date(n):n,{from:R(new Date(n.getUTCFullYear(),n.getUTCMonth(),1)),to:R(new Date(n.getUTCFullYear(),n.getUTCMonth()+1,0))}),k=()=>R(new Date(Date.now()+L)),U=(n,e)=>{const t=e?new Date(e).getTime():Date.now();return R(new Date(t+L*n))},K=(n,e={},t)=>(n=n instanceof Date?n:new Date(n),new Intl.DateTimeFormat("en-US",{...e,timeZone:"UTC"}).format(n)),A=(n,e)=>{const t=new Set;let s=n;for(;s<=e;){const r=K(s,{weekday:"short"}).toLowerCase();if(t.add(r),s=U(1,s),t.size===7)break}return t};class ${constructor(e){this.indexRequest=e}getAllCount(e="valid"){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").getAll();r.onerror=()=>{s(new l("Failed to retreive list count"))},r.onsuccess=()=>{const i=r.result;e==="valid"&&t(i.filter(a=>e==="valid"&&a.isDeleted!==!1&&a.endDate>=p()).length),e==="archived"&&t(i.filter(a=>e==="archived"&&a.isArchived&&!a.isDeleted).length)}})}getAll(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").openCursor(null,"prev");r.onerror=()=>{s(new Error("Failed to get lists"))};const i={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},a=e.offset||0,c=e.limit||50;let g=0,d=a>0,u=0;r.onsuccess=async w=>{const y=w.target?.result;if(y&&d){d=!1,y.advance(a+1);return}if(y&&!d){e.type==="recent"&&g===4&&t(i);const f=y.value;let m=(f.isArchived||f.endDate>=p())&&!f.isDeleted;m&&e.type==="archived"&&(m=f.isArchived),m=m&&(!e.getOnlyActive||e.getOnlyActive&&f.startDate>p()),m&&(g<c&&(i.data.push(f),g++),u++),y.continue()}else i.pagination.page=a?Math.ceil(u/a):1,i.pagination.total=u,i.pagination.itemsPerPage=c,i.pagination.totalPages=Math.ceil(u/c),t(i)}})}add(e){return new Promise((t,s)=>{const r=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),isArchived:!1,isDeleted:!1});(!r.endDate||!r.startDate||r.startDate>r.endDate)&&s(new M("Start and end dates are required and should be valid"));const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).add(r);i.onerror=()=>{s(new Error("Failed to get lists"))},i.onsuccess=()=>{t({...r,id:i.result})}})}async update(e){const t=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).put(t);i.onerror=()=>{r(new Error("Failed to update list"))},i.onsuccess=()=>{s(i.result)}})}get(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).get(e);r.onerror=()=>{s(new Error("Failed to get lists"))},r.onsuccess=()=>{t(r.result)}})}remove(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).delete(e);r.onerror=()=>{s(new Error("Failed to remove list"))},r.onsuccess=()=>{t(null)}})}}function O(n,e){const t=new Set,s=[];for(const r of n)t.add(r);for(const r of e)t.has(r)&&s.push(r);return s}const C=n=>n.status===b.Open&&n.carryOver&&n.startDate<p()||!!n.days.length&&(!n.endDate||!!n.endDate&&n.endDate>=p())||!n.days.length&&n.startDate>=p(),q={[h.habits]:n=>!!n.days.length,[h.archived]:n=>n.isArchived,[h.list]:(n,e)=>n.listId===e,[h.today]:n=>{const e=n.status===b.Open&&n.carryOver&&n.startDate<p();return!n.listId&&(e||n.startDate===p()&&!n.days.length||!!n.days.length&&!!O([...A(p(),p())],n.days).length)},[h.tomorrow]:n=>!n.listId&&(n.startDate===k()||!!n.days.length&&!!O([...A(k(),k())],n.days).length),[h.upcoming]:n=>!n.listId&&n.startDate>=k()&&!n.days.length,[h.dateRange]:(n,e)=>!n.listId&&(n.startDate>=e.from||n.startDate<=e.to)};class H{constructor(e){this.indexRequest=e}getHabitRecords(e,t){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("timestamp").openCursor(null,"prev"),a=t||N(new Date),c=[];i.onerror=()=>{r(new l("Failed to get habit records"))},i.onsuccess=g=>{const d=g.target?.result;if(d){const u=d.value;u.taskId===e&&u.timestamp&&u.timestamp>=a.from&&u.timestamp<=a.to&&c.push(u),d.continue()}else s(c)}})}get(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).get(e);r.onerror=()=>{s(new l("Failed to get task"))},r.onsuccess=()=>{t(r.result)}})}async add(e){const t=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:b.Open});if(t.listId){const s=await this.getListDates(t.listId);t.startDate=s.from,t.endDate=s.to}return new Promise((s,r)=>{t.startDate||(t.startDate=p());const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).add(t);i.onerror=()=>{r(new l("Failed to add new task"))},i.onsuccess=()=>{s({...t,id:i.result})}})}async update(e){const t=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);if(t.listId){const s=await this.getListDates(t.listId);t.startDate=s.from,t.endDate=s.to}return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).put(t);i.onerror=()=>{r(new Error("Failed to update task"))},i.onsuccess=()=>{s({...t,id:i.result})}})}getListDates(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Lists]).objectStore(o.Lists).get(e);r.onerror=()=>{s(new Error("Failed to get list for task"))},r.onsuccess=()=>{const i=r.result;t({from:i.startDate,to:i.endDate})}})}remove(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).delete(e);r.onerror=()=>{s(new l("Failed to remove task"))},r.onsuccess=()=>{t(null)}})}async getAll(e){let t=e.sortByPriority?"priority":"createdDate",s=e.sortByPriority?"next":"prev";e.type===h.upcoming&&!e.sortByPriority&&(t="startDate",s="next");const r=[],a=await new Promise((g,d)=>{const u=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index(t).openCursor(null,s);u.onerror=()=>{d(new l("Failed to get tasks"))};const w={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let y=0;const f=e.offset||0,m=e.limit||50;let v=0,T=f;u.onsuccess=Z=>{const P=Z.target?.result;if(P){const D=P.value;let x=!!D.listId||D.isArchived||C(D);x&&(e.type===h.dateRange?x=q.dateRange(D,e.dateRange||{from:"",to:""}):e.type===h.list?x=q.list(D,e.listId||0):x=q[e.type](D)),x&&T>0?(v++,T--,r.push(D.id)):x&&T===0&&(y<m&&(w.data.push(D),y++),r.push(D.id),v++),P.continue()}else w.pagination.page=f?Math.ceil(v/f):1,w.pagination.total=v,w.pagination.itemsPerPage=m,w.pagination.totalPages=Math.ceil(v/m),g(w)}}),c=await this.getAllTaskRecords(e.type,a.data,r.sort((g,d)=>g-d),e.activeList);return a.data=c.result,a.pagination.completed=c.completed,a}async getAllTaskRecords(e,t,s,r=!1){if(!t.length||![h.today,h.list].includes(e)||h.list===e&&!r)return{result:t,completed:0};const a=await new Promise((d,u)=>{const w=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("taskId").getAll(IDBKeyRange.upperBound(s[s.length-1]));w.onerror=()=>{u(new Error("Failed to add task record"))},w.onsuccess=()=>{d(w.result)}});let c=0;return{result:t.map(d=>{let u;return e===h.today?u=a.find(w=>w.taskId===d.id&&w.timestamp===p()):e===h.list&&(u=a.find(w=>w.taskId===d.id&&!!d.listId)),u?(d.status=u.status,d.statusUpdatedAt=u.timestamp,d.statusRecordId=u.id,u.status===b.Done&&c++):(d.status=b.Open,d.statusUpdatedAt=void 0,d.statusRecordId=void 0),d}),completed:c}}updateTaskRecord(e){if(!e.id)return delete e.id,e.timestamp||(e.timestamp=p()),new Promise((t,s)=>{try{const r=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).add(e);r.onerror=()=>{s(new Error("Failed to add task record"))},r.onsuccess=()=>{t({...e,id:r.result})}}catch(r){throw console.error(r),r}});if(!e.timestamp)throw new l("invalid timestamp");return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).put(e);r.onerror=()=>{s(new Error("Failed to update task record"))},r.onsuccess=()=>{t(e)}})}getAllByListId(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),i=[];r.onerror=()=>{s(new l(`Failed to tasks for id ${e}`))},r.onsuccess=a=>{const c=a.target.result;c?(c.value.listId===e&&i.push(c.value),c.continue()):t(i)}})}async removeTasksByListId(e){let t=!1;const s=[];try{const r=await this.getAllByListId(e);for(const i of r)try{await this.remove(i.id),s.push(i.id)}catch{t=!0}t&&new j(I.TASK,"Failed to remove some tasks from the list",{},s)}catch{}return s}updateAllTasksForList(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),i=[];r.onerror=()=>{s(new l("Failed to update tasks for list"))},r.onsuccess=a=>{const c=a.target.result;if(c){const g=c.value;if(g.listId===e.id){i.push(c.value);const d={};e.endDate&&(d.endDate=e.endDate),e.startDate&&(d.startDate=e.endDate),c.update({...g,...d})}c.continue()}else t(null)}})}}class Y{constructor(e){this.indexRequest=e}add(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Reports],"readwrite").objectStore(o.Reports).add(e);r.onerror=()=>{if(r.error?.message.includes("constraint")||r.error?.message==="Key already exists in the object store."){s(new B(r.error?.message));return}s(new l("Failed to add new report"))},r.onsuccess=()=>{t(e)}})}async get(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Reports]).objectStore(o.Reports).get(e);r.onerror=()=>{s(new l("Failed to get report"))},r.onsuccess=()=>{t(r.result)}})}}class F{constructor(e){this.indexRequest=e,this.objectNames=o}objectNames}class V extends F{get(){return new Promise((e,t)=>{const s=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();s.onerror=()=>{t(new l("Error retrieving settings"))},s.onsuccess=()=>{e(s.result[0])}})}add(e){return new Promise((t,s)=>{e.lastModifiedDate=Date.now();const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(e);r.onerror=()=>{s(new l("Error saving settings"))},r.onsuccess=()=>{t({...e,id:r.result})}})}update(e){return new Promise((t,s)=>{e.lastModifiedDate=Date.now();const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(e);r.onerror=()=>{s(new l("Error saving settings"))},r.onsuccess=()=>{t(e)}})}}class z extends F{async cleanupLists(){let e=!0,t=0;const s=await this.getAllInvalidLists();try{for(const r of s)try{t+=await this.cleanupTasks(r)}catch{e=!0}e&&new j(I.TASK,"Failed to remove some tasks from the list",{})}catch{}return e||await this.deleteLists(s),{deletedLists:s.length,deletedTasks:t}}deleteLists(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction(this.objectNames.Lists,"readwrite").objectStore(this.objectNames.Lists).delete(e);r.onerror=()=>{s(new l("Failed to clean up old list"))},r.onsuccess=()=>{t(r.result)}})}async cleanupTasks(e){const t=await this.getAllInvalidTasks(e);return new Promise((s,r)=>{const i=this.indexRequest.result.transaction(this.objectNames.Tasks,"readwrite").objectStore(this.objectNames.Tasks).delete(t);i.onerror=()=>{r(new l("Error retrieving settings"))},i.onsuccess=()=>{s(t.length)}})}getAllInvalidTasks(e){return new Promise((t,s)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).index("createdDate").openCursor();r.onerror=()=>{s(new Error("Failed to get invalid tasks"))};const i=[];r.onsuccess=a=>{const c=a.target?.result;if(c){const g=c.value;(e&&e===g.listId||!e&&!g.listId&&!C(g)&&!g.isArchived)&&i.push(g),c.continue()}else t(i.map(g=>g.id))}})}getAllInvalidLists(){return new Promise((e,t)=>{const s=this.indexRequest.result.transaction([o.Lists],"readonly").objectStore(o.Lists).index("createdDate").openCursor();s.onerror=()=>{t(new Error("Failed to get lists"))};const r=[];s.onsuccess=i=>{const a=i.target?.result;if(a){const c=a.value;(c.isDeleted||c.endDate<p()&&!c.isArchived)&&r.push(a.value),a.continue()}else e(r.map(c=>c.id))}})}}class S{tasks;lists;indexRequest;reports;cleanup;settings;static instance;async hasDatabase(){return new Promise((e,t)=>{if(!this.indexRequest){t(new l("Database does not exist"));return}try{const s=this.indexRequest.result.transaction([o.Settings]).objectStore(o.Settings).getAll();s.onerror=()=>{t(new l("Error retrieving settings"))},s.onsuccess=()=>{e(!!s.result.length)}}catch(s){if(s.message.includes("The database connection is closing")){e(!1);return}t(new l(s.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((e,t)=>{const s=indexedDB.open("personalPlanner",14);s.onerror=()=>{t(new l("Cannot use IndexDB"))},s.onsuccess=()=>{const r=s.result;r.onerror=i=>{t(new l(`Database error: ${i.target?.errorCode}`))},this.indexRequest=s,e(s)},s.onupgradeneeded=r=>{const i=s.result;if(!i.objectStoreNames.contains(o.Lists)){const a=i.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});a.createIndex("description","description"),a.createIndex("createdDate","createdDate"),a.createIndex("lastModifiedDate","lastModifiedDate"),a.createIndex("startDate","startDate"),a.createIndex("endDate","endDate"),a.createIndex("isDeleted","isDeleted"),a.createIndex("isArchived","isArchived")}if(!i.objectStoreNames.contains(o.TaskRecords)){const a=i.createObjectStore(o.TaskRecords,{autoIncrement:!0,keyPath:"id"});a.createIndex("taskId","taskId"),a.createIndex("status","status"),a.createIndex("timestamp","timestamp")}if(i.objectStoreNames.contains(o.Reports)||i.createObjectStore(o.Reports,{keyPath:"date"}).createIndex("count","count"),!i.objectStoreNames.contains(o.Settings)){const a=i.createObjectStore(o.Settings,{keyPath:"id",autoIncrement:!0});a.createIndex("archive","archive"),a.createIndex("archiveFor","archiveFor"),a.createIndex("image","image"),a.createIndex("name","name"),a.createIndex("lastModifiedDate","lastModifiedDate"),a.createIndex("theme","theme")}if(!i.objectStoreNames.contains(o.Tasks)){const a=i.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"});a.createIndex("listId","listId"),a.createIndex("description","description"),a.createIndex("note","note"),a.createIndex("startTime","startTime"),a.createIndex("endTime","endTime"),a.createIndex("priority","priority"),a.createIndex("status","status"),a.createIndex("days","days"),a.createIndex("carryOver","carryOver"),a.createIndex("createdDate","createdDate"),a.createIndex("lastModifiedDate","lastModifiedDate"),a.createIndex("startDate","startDate"),a.createIndex("endDate","endDate"),a.createIndex("isDeleted","isDeleted"),a.createIndex("isArchived","isArchived")}if(r.oldVersion===13){if(console.info("Upgrading from version 13."),!i.objectStoreNames.contains(o.Lists)){const a=i.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});a.createIndex("type","type"),a.createIndex("budget","budget")}i.objectStoreNames.contains(o.Tasks)||i.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"}).createIndex("amount","amount")}}})}repositories(){if(!this.indexRequest)throw new l;return{tasks:this.tasks||new H(this.indexRequest),cleanup:this.cleanup||new z(this.indexRequest),lists:this.lists||new $(this.indexRequest),reports:this.reports||new Y(this.indexRequest),settings:this.settings||new V(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new S,await this.instance.start()),this.instance}async clear(e){this.indexRequest&&this.indexRequest.result.transaction([e],"readwrite").objectStore(e).clear()}async delete(){return new Promise((e,t)=>{this.indexRequest?.result.close();const s=indexedDB.deleteDatabase("personalPlanner");s.onerror=()=>{t(new l("Error deleting database."))},s.onsuccess=()=>{this.indexRequest=void 0,e(null)},s.onblocked=()=>{t(new l("Request is blocked"))}})}}onmessage=async function(n){console.info(n.data);const e=await S.getInstance();try{await new E(e.repositories()).cleanOldRecords(),this.postMessage("clean up completed")}catch{}}})();
