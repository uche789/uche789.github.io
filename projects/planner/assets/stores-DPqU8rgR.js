import{d as A,T as m,O as o,g as f,f as C,F as p,a as k,b as L,c as N}from"./layout-ChbXxXJa.js";const Q=A("tasks",{state:()=>({pageListId:0,lists:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},habits:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},todaysTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},allUpcomingTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},tomorrowsTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},selectedListTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},recentList:[],updatingState:{list:!1,habit:!1,task:!1},currentSelectedTask:null}),getters:{selectedPageList(){return this.lists.data.find(t=>t.id===this.pageListId)},countTodaysTask(){return this.todaysTasks.pagination.total},countList(){return this.lists.pagination.total}},actions:{async getTodaysTasks(t=1,e=!1,s=!1){const a=10*t-10;this.todaysTasks=await this.$api.service.getTodaysList(a,10,e,s)},async getTomorrowTasks(t=1,e=!1){const i=7*t-7;this.tomorrowsTasks=await this.$api.service.getTomorrowsList(i,7,e)},async getUpcoming(t=1,e=!1){const i=20*t-20;this.allUpcomingTasks=await this.$api.service.getUpcoming(i,20,e)},async getAllList(t=1){const s=50*t-50;this.lists=await this.$api.service.getAllList(s,50)},async getCount(){this.getAllList(),this.getTodaysTasks()},async addList(t){return await this.$api.service.addList(t)},async getList(t){let e=this.lists.data.findIndex(s=>s.id===t);if(e===-1){const s=await this.$api.service.getList(t);this.lists.data.push(s),e=this.lists.data.length-1}return this.lists.data[e]},async getTaskForList(t,e=1,s=!1,i=!1){const n=20*e-20;this.selectedListTasks=await this.$api.service.getTaskForList(t,n,20,s,i)},async deleteList(t){await this.$api.service.deleteList(t),this.recentList=this.recentList.filter(e=>e.id!==t)},async updateList(t){const e=this.lists.data.findIndex(s=>s.id===t.id);await this.$api.service.updateList(t),this.lists.data[e]={...this.lists.data[e],...t}},setPageListId(t){this.pageListId=t},async getHabits(t=1,e=!1){const i=20*t-20;this.habits=await this.$api.service.getHabits(i,20,e)},async addTask(t){await this.$api.service.addTask(t)},async updateTask(t){const e=await this.$api.service.updateTask(t);if(t.listId){let s=this.selectedListTasks.data.find(i=>i.id===t.id);if(s){s={...s,...e};return}}},async changeTaskStatus(t,e){const s=()=>e||(!e&&e===m.Open?m.Done:!e&&t.status===m.Done?m.Open:m.Done),i=await this.$api.service.updateTask({id:t.id,status:s(),statusRecordId:t.statusRecordId,statusUpdatedAt:t.statusUpdatedAt},!0);return t.statusRecordId=i.statusRecordId,t.status=i.status,t.statusUpdatedAt=i.statusUpdatedAt,e},async deleteTask(t){await this.$api.service.deleteTask(t)},async getRecentList(){this.recentList=(await this.$api.service.getRecentLists()).data},async setUpdatingState(t,e){this.updatingState[t]=e},async getCurrentlySelectedTast(t){this.currentSelectedTask=await this.$api.service.getTask(t)}}});var y=(t=>(t.isTabletPortrait="isTabletPortrait",t.isTabletLandscape="isTabletLandscape",t.isMobilePortrait="isMobilePortrait",t.isMobileLandscape="isMobileLandscape",t))(y||{});class l extends Error{}class B extends Error{}class W extends Error{}class U extends Error{}const F={RECORD:"RECORD",TASK:"TASK"};class O extends Error{constructor(e,s,i,a){super(s,i),this.key=e,this.data=a}}class K{constructor(e){this.indexRequest=e}getAllCount(e="valid"){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").getAll();a.onerror=()=>{i(new l("Failed to retreive list count"))},a.onsuccess=()=>{const n=a.result;e==="valid"&&s(n.filter(r=>e==="valid"&&r.isDeleted!==!1&&r.endDate>=f()).length),e==="archived"&&s(n.filter(r=>e==="archived"&&r.isArchived&&!r.isDeleted).length)}})}getAll(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").openCursor(null,"prev");a.onerror=()=>{i(new Error("Failed to get lists"))};const n={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},r=e.offset||0,c=e.limit||50;let u=0,d=r>0,g=0;a.onsuccess=async h=>{const b=h.target?.result;if(b&&d){d=!1,b.advance(r+1);return}if(b&&!d){e.type==="recent"&&u===4&&s(n);const w=b.value;let x=(w.isArchived||w.endDate>=f())&&!w.isDeleted;x&&e.type==="archived"&&(x=w.isArchived),x=x&&(!e.getOnlyActive||e.getOnlyActive&&w.startDate>f()),x&&(u<c&&(n.data.push(w),u++),g++),b.continue()}else n.pagination.page=r?Math.ceil(g/r):1,n.pagination.total=g,n.pagination.itemsPerPage=c,n.pagination.totalPages=Math.ceil(g/c),s(n)}})}add(e){return new Promise((s,i)=>{const a=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),isArchived:!1,isDeleted:!1});(!a.endDate||!a.startDate||a.startDate>a.endDate)&&i(new B("Start and end dates are required and should be valid"));const n=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).add(a);n.onerror=()=>{i(new Error("Failed to get lists"))},n.onsuccess=()=>{s({...a,id:n.result})}})}async update(e){const s=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);return new Promise((i,a)=>{const n=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).put(s);n.onerror=()=>{a(new Error("Failed to update list"))},n.onsuccess=()=>{i(n.result)}})}get(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).get(e);a.onerror=()=>{i(new Error("Failed to get lists"))},a.onsuccess=()=>{s(a.result)}})}remove(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).delete(e);a.onerror=()=>{i(new Error("Failed to remove list"))},a.onsuccess=()=>{s(null)}})}}function I(t,e){const s=new Set,i=[];for(const a of t)s.add(a);for(const a of e)s.has(a)&&i.push(a);return i}function X(t){const s=C(new Date,{hour12:!1,hour:"numeric",minute:"numeric"});return t>s}const E=t=>t.status===m.Open&&t.carryOver&&t.startDate<f()||!!t.days.length&&(!t.endDate||!!t.endDate&&t.endDate>=f())||!t.days.length&&t.startDate>=f(),S={[p.habits]:t=>!!t.days.length,[p.archived]:t=>t.isArchived,[p.list]:(t,e)=>t.listId===e,[p.today]:t=>{const e=t.status===m.Open&&t.carryOver&&t.startDate<f();return!t.listId&&(e||t.startDate===f()&&!t.days.length||!!t.days.length&&!!I([...k(f(),f())],t.days).length)},[p.tomorrow]:t=>!t.listId&&(t.startDate===L()||!!t.days.length&&!!I([...k(L(),L())],t.days).length),[p.upcoming]:t=>!t.listId&&t.startDate>=N(2),[p.dateRange]:(t,e)=>!t.listId&&(t.startDate>=e.from||t.startDate<=e.to)};class H{constructor(e){this.indexRequest=e}get(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).get(e);a.onerror=()=>{i(new l("Failed to get task"))},a.onsuccess=()=>{s(a.result)}})}async add(e){const s=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:m.Open});if(s.listId){const i=await this.getListDates(s.listId);s.startDate=i.from,s.endDate=i.to}return new Promise((i,a)=>{s.startDate||(s.startDate=f());const n=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).add(s);n.onerror=()=>{a(new l("Failed to add new task"))},n.onsuccess=()=>{i({...s,id:n.result})}})}async update(e){const s=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);if(s.listId){const i=await this.getListDates(s.listId);s.startDate=i.from,s.endDate=i.to}return new Promise((i,a)=>{const n=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).put(s);n.onerror=()=>{a(new Error("Failed to update task"))},n.onsuccess=()=>{i({...s,id:n.result})}})}getListDates(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Lists]).objectStore(o.Lists).get(e);a.onerror=()=>{i(new Error("Failed to get list for task"))},a.onsuccess=()=>{const n=a.result;s({from:n.startDate,to:n.endDate})}})}remove(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).delete(e);a.onerror=()=>{i(new l("Failed to remove task"))},a.onsuccess=()=>{s(null)}})}async getAll(e){let s=e.sortByPriority?"priority":"createdDate",i=e.sortByPriority?"next":"prev";e.sortByCompletion&&(s="status",i="next");const a=[],r=await new Promise((u,d)=>{const g=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index(s).openCursor(null,i);g.onerror=()=>{d(new l("Failed to get tasks"))};const h={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let b=0;const w=e.offset||0,x=e.limit||50;let v=0,P=w;g.onsuccess=$=>{const R=$.target?.result;if(R){const D=R.value;let T=!!D.listId||D.isArchived||E(D);T&&(e.type===p.dateRange?T=S.dateRange(D,e.dateRange||{from:"",to:""}):e.type===p.list?T=S.list(D,e.listId||0):T=S[e.type](D)),T&&P>0?(v++,P--,a.push(D.id)):T&&P===0&&(b<x&&(h.data.push(D),b++),a.push(D.id),v++),R.continue()}else h.pagination.page=w?Math.ceil(v/w):1,h.pagination.total=v,h.pagination.itemsPerPage=x,h.pagination.totalPages=Math.ceil(v/x),u(h)}}),c=await this.getAllTaskRecords(e.type,r.data,a.sort((u,d)=>u-d),e.activeList);return r.data=c.result,r.pagination.completed=c.completed,r}async getAllTaskRecords(e,s,i,a=!1){if(!s.length||![p.today,p.list].includes(e)||p.list===e&&!a)return{result:s,completed:0};const r=await new Promise((d,g)=>{const h=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("taskId").getAll(IDBKeyRange.upperBound(i[i.length-1]));h.onerror=()=>{g(new Error("Failed to add task record"))},h.onsuccess=()=>{d(h.result)}});let c=0;return{result:s.map(d=>{let g;return e===p.today?g=r.find(h=>h.taskId===d.id&&h.timestamp===f()):e===p.list&&(g=r.find(h=>h.taskId===d.id&&!!d.listId)),g?(d.status=g.status,d.statusUpdatedAt=g.timestamp,d.statusRecordId=g.id,g.status===m.Done&&c++):(d.status=m.Open,d.statusUpdatedAt=void 0,d.statusRecordId=void 0),d}),completed:c}}updateTaskRecord(e){if(!e.id)return delete e.id,e.timestamp||(e.timestamp=f()),new Promise((s,i)=>{try{const a=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).add(e);a.onerror=()=>{i(new Error("Failed to add task record"))},a.onsuccess=()=>{s({...e,id:a.result})}}catch(a){throw console.error(a),a}});if(!e.timestamp)throw new l("invalid timestamp");return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).put(e);a.onerror=()=>{i(new Error("Failed to update task record"))},a.onsuccess=()=>{s(e)}})}getAllByListId(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),n=[];a.onerror=()=>{i(new l(`Failed to tasks for id ${e}`))},a.onsuccess=r=>{const c=r.target.result;c?(c.value.listId===e&&n.push(c.value),c.continue()):s(n)}})}async removeTasksByListId(e){let s=!1;const i=[];try{const a=await this.getAllByListId(e);for(const n of a)try{await this.remove(n.id),i.push(n.id)}catch{s=!0}s&&new O(F.TASK,"Failed to remove some tasks from the list",{},i)}catch{}return i}updateAllTasksForList(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),n=[];a.onerror=()=>{i(new l("Failed to update tasks for list"))},a.onsuccess=r=>{const c=r.target.result;if(c){const u=c.value;if(u.listId===e.id){n.push(c.value);const d={};e.endDate&&(d.endDate=e.endDate),e.startDate&&(d.startDate=e.endDate),c.update({...u,...d})}c.continue()}else s(null)}})}}class V{constructor(e){this.indexRequest=e}add(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Reports],"readwrite").objectStore(o.Reports).add(e);a.onerror=()=>{if(a.error?.message.includes("constraint")||a.error?.message==="Key already exists in the object store."){i(new U(a.error?.message));return}i(new l("Failed to add new report"))},a.onsuccess=()=>{s(e)}})}async get(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Reports]).objectStore(o.Reports).get(e);a.onerror=()=>{i(new l("Failed to get report"))},a.onsuccess=()=>{s(a.result)}})}}class M{constructor(e){this.indexRequest=e,this.objectNames=o}objectNames}class G extends M{get(){return new Promise((e,s)=>{const i=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();i.onerror=()=>{s(new l("Error retrieving settings"))},i.onsuccess=()=>{e(i.result[0])}})}add(e){return new Promise((s,i)=>{e.lastModifiedDate=Date.now();const a=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(e);a.onerror=()=>{i(new l("Error saving settings"))},a.onsuccess=()=>{s({...e,id:a.result})}})}update(e){return new Promise((s,i)=>{e.lastModifiedDate=Date.now();const a=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(e);a.onerror=()=>{i(new l("Error saving settings"))},a.onsuccess=()=>{s(e)}})}}class z extends M{async cleanupLists(){let e=!0,s=0;const i=await this.getAllInvalidLists();try{for(const a of i)try{s+=await this.cleanupTasks(a)}catch{e=!0}e&&new O(F.TASK,"Failed to remove some tasks from the list",{})}catch{}return e||await this.deleteLists(i),{deletedLists:i.length,deletedTasks:s}}deleteLists(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction(this.objectNames.Lists,"readwrite").objectStore(this.objectNames.Lists).delete(e);a.onerror=()=>{i(new l("Failed to clean up old list"))},a.onsuccess=()=>{s(a.result)}})}async cleanupTasks(e){const s=await this.getAllInvalidTasks(e);return new Promise((i,a)=>{const n=this.indexRequest.result.transaction(this.objectNames.Tasks,"readwrite").objectStore(this.objectNames.Tasks).delete(s);n.onerror=()=>{a(new l("Error retrieving settings"))},n.onsuccess=()=>{i(s.length)}})}getAllInvalidTasks(e){return new Promise((s,i)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).index("createdDate").openCursor();a.onerror=()=>{i(new Error("Failed to get invalid tasks"))};const n=[];a.onsuccess=r=>{const c=r.target?.result;if(c){const u=c.value;(e&&e===u.listId||!e&&!u.listId&&!E(u)&&!u.isArchived)&&n.push(u),c.continue()}else s(n.map(u=>u.id))}})}getAllInvalidLists(){return new Promise((e,s)=>{const i=this.indexRequest.result.transaction([o.Lists],"readonly").objectStore(o.Lists).index("createdDate").openCursor();i.onerror=()=>{s(new Error("Failed to get lists"))};const a=[];i.onsuccess=n=>{const r=n.target?.result;if(r){const c=r.value;(c.isDeleted||c.endDate<f()&&!c.isArchived)&&a.push(r.value),r.continue()}else e(a.map(c=>c.id))}})}}class q{tasks;lists;indexRequest;reports;cleanup;settings;static instance;async hasDatabase(){return new Promise((e,s)=>{if(!this.indexRequest){s(new l("Database does not exist"));return}try{const i=this.indexRequest.result.transaction([o.Settings]).objectStore(o.Settings).getAll();i.onerror=()=>{s(new l("Error retrieving settings"))},i.onsuccess=()=>{e(!!i.result.length)}}catch(i){if(i.message.includes("The database connection is closing")){e(!1);return}s(new l(i.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((e,s)=>{const i=indexedDB.open("personalPlanner",13);i.onerror=()=>{s(new l("Cannot use IndexDB"))},i.onsuccess=()=>{const a=i.result;a.onerror=n=>{s(new l(`Database error: ${n.target?.errorCode}`))},this.indexRequest=i,e(i)},i.onupgradeneeded=a=>{const n=i.result;if(!n.objectStoreNames.contains(o.Lists)){const r=n.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});r.createIndex("description","description"),r.createIndex("createdDate","createdDate"),r.createIndex("lastModifiedDate","lastModifiedDate"),r.createIndex("startDate","startDate"),r.createIndex("endDate","endDate"),r.createIndex("isDeleted","isDeleted"),r.createIndex("isArchived","isArchived")}if(!n.objectStoreNames.contains(o.TaskRecords)){const r=n.createObjectStore(o.TaskRecords,{autoIncrement:!0,keyPath:"id"});r.createIndex("taskId","taskId"),r.createIndex("status","status"),r.createIndex("timestamp","timestamp")}if(a.oldVersion,n.objectStoreNames.contains(o.Reports)||n.createObjectStore(o.Reports,{keyPath:"date"}).createIndex("count","count"),!n.objectStoreNames.contains(o.Settings)){const r=n.createObjectStore(o.Settings,{keyPath:"id",autoIncrement:!0});r.createIndex("archive","archive"),r.createIndex("archiveFor","archiveFor"),r.createIndex("image","image"),r.createIndex("name","name"),r.createIndex("lastModifiedDate","lastModifiedDate"),r.createIndex("theme","theme")}if(!n.objectStoreNames.contains(o.Tasks)){const r=n.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"});r.createIndex("listId","listId"),r.createIndex("description","description"),r.createIndex("note","note"),r.createIndex("startTime","startTime"),r.createIndex("endTime","endTime"),r.createIndex("priority","priority"),r.createIndex("status","status"),r.createIndex("days","days"),r.createIndex("carryOver","carryOver"),r.createIndex("createdDate","createdDate"),r.createIndex("lastModifiedDate","lastModifiedDate"),r.createIndex("startDate","startDate"),r.createIndex("endDate","endDate"),r.createIndex("isDeleted","isDeleted"),r.createIndex("isArchived","isArchived")}}})}repositories(){if(!this.indexRequest)throw new l;return{tasks:this.tasks||new H(this.indexRequest),cleanup:this.cleanup||new z(this.indexRequest),lists:this.lists||new K(this.indexRequest),reports:this.reports||new V(this.indexRequest),settings:this.settings||new G(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new q,await this.instance.start()),this.instance}async clear(e){this.indexRequest&&this.indexRequest.result.transaction([e],"readwrite").objectStore(e).clear()}async delete(){return new Promise((e,s)=>{this.indexRequest?.result.close();const i=indexedDB.deleteDatabase("personalPlanner");i.onerror=()=>{s(new l("Error deleting database."))},i.onsuccess=()=>{this.indexRequest=void 0,e(null)},i.onblocked=()=>{s(new l("Request is blocked"))}})}}const j={id:0,name:"",archive:!1,archiveFor:30,theme:"default"},Y=A("appStore",{state:()=>({isMobileLandscape:!1,isMobilePortrait:!1,isTabletLandscape:!1,isTabletPortrait:!1,device:{[y.isTabletPortrait]:!1,[y.isTabletLandscape]:!1,[y.isMobilePortrait]:!1,[y.isMobileLandscape]:!1},settings:j,globalLoading:!1}),getters:{isTablet(){return this.device.isTabletLandscape||this.device.isTabletPortrait},isMobile(){return this.device.isMobileLandscape||this.device.isMobilePortrait}},actions:{setMediaMatch(t,e){this.device[t]=e},async getSettings(t=!1){!t&&this.settings.id!==0||(this.settings=await this.$api.service.getSettings())},async updateSettings(t){this.settings=await this.$api.service.updateSettings(t),this.getSettings(!0)},async deleteApp(){return this.settings=j,(await q.getInstance()).delete()},async addSettings(t){this.settings=await this.$api.service.addSettings(t)},setGlobalLoading(t){this.globalLoading=t}}}),Z=({app:t})=>({$api:t.config.globalProperties.$api});export{y as D,q as L,W as N,Q as a,X as o,Z as p,Y as u};
