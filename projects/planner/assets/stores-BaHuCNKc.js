import{H as se,b as re,I as ae,J as ne,c as ie,K as N,L as z,M as De,i as ye,w as xe,r as Se,N as Te,O as Re,P as Pe,n as Le,Q as ke}from"./RichEditor-DQzkoqnZ.js";var qe=!1;/*!
 * pinia v2.3.0
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */let oe;const _=e=>oe=e,ce=Symbol();function V(e){return e&&typeof e=="object"&&Object.prototype.toString.call(e)==="[object Object]"&&typeof e.toJSON!="function"}var F;(function(e){e.direct="direct",e.patchObject="patch object",e.patchFunction="patch function"})(F||(F={}));function Ye(){const e=se(!0),t=e.run(()=>re({}));let r=[],s=[];const a=ae({install(n){_(a),a._a=n,n.provide(ce,a),n.config.globalProperties.$pinia=a,s.forEach(i=>r.push(i)),s=[]},use(n){return!this._a&&!qe?s.push(n):r.push(n),this},_p:r,_a:null,_e:e,_s:new Map,state:t});return a}const le=()=>{};function Z(e,t,r,s=le){e.push(t);const a=()=>{const n=e.indexOf(t);n>-1&&(e.splice(n,1),s())};return!r&&Re()&&Pe(a),a}function j(e,...t){e.slice().forEach(r=>{r(...t)})}const Ie=e=>e(),G=Symbol(),K=Symbol();function J(e,t){e instanceof Map&&t instanceof Map?t.forEach((r,s)=>e.set(s,r)):e instanceof Set&&t instanceof Set&&t.forEach(e.add,e);for(const r in t){if(!t.hasOwnProperty(r))continue;const s=t[r],a=e[r];V(a)&&V(s)&&e.hasOwnProperty(r)&&!N(s)&&!z(s)?e[r]=J(a,s):e[r]=s}return e}const je=Symbol();function Ae(e){return!V(e)||!e.hasOwnProperty(je)}const{assign:k}=Object;function Ce(e){return!!(N(e)&&e.effect)}function Me(e,t,r,s){const{state:a,actions:n,getters:i}=t,c=r.state.value[e];let u;function l(){c||(r.state.value[e]=a?a():{});const d=ke(r.state.value[e]);return k(d,n,Object.keys(i||{}).reduce((f,b)=>(f[b]=ae(ie(()=>{_(r);const m=r._s.get(e);return i[b].call(m,m)})),f),{}))}return u=de(e,l,t,r,s,!0),u}function de(e,t,r={},s,a,n){let i;const c=k({actions:{}},r),u={deep:!0};let l,d,f=[],b=[],m;const w=s.state.value[e];!n&&!w&&(s.state.value[e]={}),re({});let P;function q(g){let h;l=d=!1,typeof g=="function"?(g(s.state.value[e]),h={type:F.patchFunction,storeId:e,events:m}):(J(s.state.value[e],g),h={type:F.patchObject,payload:g,storeId:e,events:m});const x=P=Symbol();Le().then(()=>{P===x&&(l=!0)}),d=!0,j(f,h,s.state.value[e])}const B=n?function(){const{state:h}=r,x=h?h():{};this.$patch(I=>{k(I,x)})}:le;function A(){i.stop(),f=[],b=[],s._s.delete(e)}const y=(g,h="")=>{if(G in g)return g[K]=h,g;const x=function(){_(s);const I=Array.from(arguments),M=[],H=[];function be(S){M.push(S)}function ve(S){H.push(S)}j(b,{args:I,name:x[K],store:R,after:be,onError:ve});let O;try{O=g.apply(this&&this.$id===e?this:R,I)}catch(S){throw j(H,S),S}return O instanceof Promise?O.then(S=>(j(M,S),S)).catch(S=>(j(H,S),Promise.reject(S))):(j(M,O),O)};return x[G]=!0,x[K]=h,x},L={_p:s,$id:e,$onAction:Z.bind(null,b),$patch:q,$reset:B,$subscribe(g,h={}){const x=Z(f,g,h.detached,()=>I()),I=i.run(()=>xe(()=>s.state.value[e],M=>{(h.flush==="sync"?d:l)&&g({storeId:e,type:F.direct,events:m},M)},k({},u,h)));return x},$dispose:A},R=Se(L);s._s.set(e,R);const C=(s._a&&s._a.runWithContext||Ie)(()=>s._e.run(()=>(i=se()).run(()=>t({action:y}))));for(const g in C){const h=C[g];if(N(h)&&!Ce(h)||z(h))n||(w&&Ae(h)&&(N(h)?h.value=w[g]:J(h,w[g])),s.state.value[e][g]=h);else if(typeof h=="function"){const x=y(h,g);C[g]=x,c.actions[g]=h}}return k(R,C),k(ne(R),C),Object.defineProperty(R,"$state",{get:()=>s.state.value[e],set:g=>{q(h=>{k(h,g)})}}),s._p.forEach(g=>{k(R,i.run(()=>g({store:R,app:s._a,pinia:s,options:c})))}),w&&n&&r.hydrate&&r.hydrate(R.$state,w),l=!0,d=!0,R}/*! #__NO_SIDE_EFFECTS__ */function ue(e,t,r){let s,a;const n=typeof t=="function";typeof e=="string"?(s=e,a=n?r:t):(a=e,s=e.id);function i(c,u){const l=Te();return c=c||(l?ye(ce,null):null),c&&_(c),c=oe,c._s.has(s)||(n?de(s,t,a,c):Me(s,a,c)),c._s.get(s)}return i.$id=s,i}function Ve(e){{const t=ne(e),r={};for(const s in t){const a=t[s];a.effect?r[s]=ie({get:()=>e[s],set(n){e[s]=n}}):(N(a)||z(a))&&(r[s]=De(e,s))}return r}}const Je={mon:"Monday",tue:"Tuesday",wed:"Wednesday",thu:"Thursday",fri:"Friday",sat:"Saturday",sun:"Sunday"};var T=(e=>(e[e.Open=1]="Open",e[e.Progress=2]="Progress",e[e.Done=3]="Done",e))(T||{}),Oe=(e=>(e[e.High=1]="High",e[e.Medium=2]="Medium",e[e.Normal=3]="Normal",e[e.Trivial=4]="Trivial",e))(Oe||{});const ze={1:"High",2:"Medium",3:"Normal",4:"Trivial"};var v=(e=>(e.list="list",e.dateRange="dateRange",e.tomorrow="tomorrow",e.today="today",e.upcoming="upcoming",e.habits="habits",e.archived="archived",e))(v||{});const o={Lists:"lists",Tasks:"tasks",Settings:"appSettings",Reports:"reports",TaskRecords:"taskRecords"},Qe=ue("tasks",{state:()=>({pageListId:0,lists:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},habits:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},todaysTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},allUpcomingTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},tomorrowsTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},selectedListTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},recentList:[],updatingState:{list:!1,habit:!1,task:!1},currentSelectedTask:{taskItem:null,records:[]}}),getters:{selectedPageList(){return this.lists.data.find(e=>e.id===this.pageListId)},countTodaysTask(){return this.todaysTasks.pagination.total},countList(){return this.lists.pagination.total}},actions:{async getTodaysTasks(e=1,t=!1,r=!1){const a=10*e-10;this.todaysTasks=await this.$api.service.getTodaysList(a,10,t,r)},async getTomorrowTasks(e=1,t=!1){const s=7*e-7;this.tomorrowsTasks=await this.$api.service.getTomorrowsList(s,7,t)},async getUpcoming(e=1,t=!1){const s=20*e-20;this.allUpcomingTasks=await this.$api.service.getUpcoming(s,20,t)},async getAllList(e=1){const r=50*e-50;this.lists=await this.$api.service.getAllList(r,50)},async getCount(){this.getAllList(),this.getTodaysTasks()},async addList(e){return await this.$api.service.addList(e)},async getList(e){let t=this.lists.data.findIndex(r=>r.id===e);if(t===-1){const r=await this.$api.service.getList(e);this.lists.data.push(r),t=this.lists.data.length-1}return this.lists.data[t]},async getTaskForList(e,t=1,r=!1,s=!1){const n=20*t-20;this.selectedListTasks=await this.$api.service.getTaskForList(e,n,20,r,s)},async deleteList(e){await this.$api.service.deleteList(e),this.recentList=this.recentList.filter(t=>t.id!==e)},async updateList(e){const t=this.lists.data.findIndex(r=>r.id===e.id);await this.$api.service.updateList(e),this.lists.data[t]={...this.lists.data[t],...e}},setPageListId(e){this.pageListId=e},async getHabits(e=1,t=!1){const s=20*e-20;this.habits=await this.$api.service.getHabits(s,20,t)},async addTask(e){await this.$api.service.addTask(e)},async updateTask(e){const t=await this.$api.service.updateTask(e);if(e.listId){let r=this.selectedListTasks.data.find(s=>s.id===e.id);if(r){r={...r,...t};return}}},async changeTaskStatus(e,t){const r=()=>t||(!t&&t===T.Open?T.Done:!t&&e.status===T.Done?T.Open:T.Done),s=await this.$api.service.updateTask({id:e.id,status:r(),statusRecordId:e.statusRecordId,statusUpdatedAt:e.statusUpdatedAt},!0);return e.statusRecordId=s.statusRecordId,e.status=s.status,e.statusUpdatedAt=s.statusUpdatedAt,t},async deleteTask(e){await this.$api.service.deleteTask(e)},async getRecentList(){this.recentList=(await this.$api.service.getRecentLists()).data},async setUpdatingState(e,t){this.updatingState[e]=t},async getCurrentlySelectedTast(e){this.currentSelectedTask.taskItem=await this.$api.service.getTask(e),this.currentSelectedTask.taskItem.days.length>0&&(this.currentSelectedTask.records=await this.$api.service.getHabitRecords(e))}}});var E=(e=>(e.isTabletPortrait="isTabletPortrait",e.isTabletLandscape="isTabletLandscape",e.isMobilePortrait="isMobilePortrait",e.isMobileLandscape="isMobileLandscape",e))(E||{});class p extends Error{}class Ee extends Error{}class Ze extends Error{}class Fe extends Error{}const he={RECORD:"RECORD",TASK:"TASK"};class ge extends Error{constructor(t,r,s,a){super(r,s),this.key=t,this.data=a}}const fe=60*60*24*1e3;function $(e){const t=e.getUTCMonth()+1,r=e.getUTCDate();return`${e.getUTCFullYear()}-${t<10?"0"+t:t}-${r<10?"0"+r:r}`}const D=()=>$(new Date),Ge=e=>{let t;return t=new Date,{fullYear:t.getUTCFullYear(),month:Number(U(t,{month:"numeric"})),monthString:U(t,{month:"long"}),numberOfDays:new Date(t.getUTCFullYear(),t.getUTCMonth()+1,0).getDate()}},Ne=e=>(e=typeof e=="string"?new Date(e):e,{from:$(new Date(e.getUTCFullYear(),e.getUTCMonth(),1)),to:$(new Date(e.getUTCFullYear(),e.getUTCMonth()+1,0))}),W=()=>$(new Date(Date.now()+fe)),pe=(e,t)=>{const r=t?new Date(t).getTime():Date.now();return $(new Date(r+fe*e))},U=(e,t={},r)=>(e=e instanceof Date?e:new Date(e),new Intl.DateTimeFormat("en-US",{...t,timeZone:"UTC"}).format(e)),X=(e,t)=>{const r=new Set;let s=e;for(;s<=t;){const a=U(s,{weekday:"short"}).toLowerCase();if(r.add(a),s=pe(1,s),r.size===7)break}return r};class $e{constructor(t){this.indexRequest=t}getAllCount(t="valid"){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").getAll();a.onerror=()=>{s(new p("Failed to retreive list count"))},a.onsuccess=()=>{const n=a.result;t==="valid"&&r(n.filter(i=>t==="valid"&&i.isDeleted!==!1&&i.endDate>=D()).length),t==="archived"&&r(n.filter(i=>t==="archived"&&i.isArchived&&!i.isDeleted).length)}})}getAll(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").openCursor(null,"prev");a.onerror=()=>{s(new Error("Failed to get lists"))};const n={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},i=t.offset||0,c=t.limit||50;let u=0,l=i>0,d=0;a.onsuccess=async f=>{const b=f.target?.result;if(b&&l){l=!1,b.advance(i+1);return}if(b&&!l){t.type==="recent"&&u===4&&r(n);const m=b.value;let w=(m.isArchived||m.endDate>=D())&&!m.isDeleted;w&&t.type==="archived"&&(w=m.isArchived),w=w&&(!t.getOnlyActive||t.getOnlyActive&&m.startDate>D()),w&&(u<c&&(n.data.push(m),u++),d++),b.continue()}else n.pagination.page=i?Math.ceil(d/i):1,n.pagination.total=d,n.pagination.itemsPerPage=c,n.pagination.totalPages=Math.ceil(d/c),r(n)}})}add(t){return new Promise((r,s)=>{const a=Object.assign({},t,{createdDate:Date.now(),lastModifiedDate:Date.now(),isArchived:!1,isDeleted:!1});(!a.endDate||!a.startDate||a.startDate>a.endDate)&&s(new Ee("Start and end dates are required and should be valid"));const n=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).add(a);n.onerror=()=>{s(new Error("Failed to get lists"))},n.onsuccess=()=>{r({...a,id:n.result})}})}async update(t){const r=Object.assign({},await this.get(t.id),{lastModifiedDate:String(Date.now())},t);return new Promise((s,a)=>{const n=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).put(r);n.onerror=()=>{a(new Error("Failed to update list"))},n.onsuccess=()=>{s(n.result)}})}get(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).get(t);a.onerror=()=>{s(new Error("Failed to get lists"))},a.onsuccess=()=>{r(a.result)}})}remove(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).delete(t);a.onerror=()=>{s(new Error("Failed to remove list"))},a.onsuccess=()=>{r(null)}})}}function ee(e,t){const r=new Set,s=[];for(const a of e)r.add(a);for(const a of t)r.has(a)&&s.push(a);return s}function Xe(e){const r=U(new Date,{hour12:!1,hour:"numeric",minute:"numeric"});return e>r}const me=e=>e.status===T.Open&&e.carryOver&&e.startDate<D()||!!e.days.length&&(!e.endDate||!!e.endDate&&e.endDate>=D())||!e.days.length&&e.startDate>=D(),Y={[v.habits]:e=>!!e.days.length,[v.archived]:e=>e.isArchived,[v.list]:(e,t)=>e.listId===t,[v.today]:e=>{const t=e.status===T.Open&&e.carryOver&&e.startDate<D();return!e.listId&&(t||e.startDate===D()&&!e.days.length||!!e.days.length&&!!ee([...X(D(),D())],e.days).length)},[v.tomorrow]:e=>!e.listId&&(e.startDate===W()||!!e.days.length&&!!ee([...X(W(),W())],e.days).length),[v.upcoming]:e=>!e.listId&&e.startDate>=pe(2),[v.dateRange]:(e,t)=>!e.listId&&(e.startDate>=t.from||e.startDate<=t.to)};class Ue{constructor(t){this.indexRequest=t}getHabitRecords(t,r){return new Promise((s,a)=>{const n=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("timestamp").openCursor(null,"prev"),i=r||Ne(new Date),c=[];n.onerror=()=>{a(new p("Failed to get habit records"))},n.onsuccess=u=>{const l=u.target?.result;if(l){const d=l.value;d.taskId===t&&d.timestamp&&d.timestamp>=i.from&&d.timestamp<=i.to&&c.push(d),l.continue()}else s(c)}})}get(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).get(t);a.onerror=()=>{s(new p("Failed to get task"))},a.onsuccess=()=>{r(a.result)}})}async add(t){const r=Object.assign({},t,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:T.Open});if(r.listId){const s=await this.getListDates(r.listId);r.startDate=s.from,r.endDate=s.to}return new Promise((s,a)=>{r.startDate||(r.startDate=D());const n=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).add(r);n.onerror=()=>{a(new p("Failed to add new task"))},n.onsuccess=()=>{s({...r,id:n.result})}})}async update(t){const r=Object.assign({},await this.get(t.id),{lastModifiedDate:String(Date.now())},t);if(r.listId){const s=await this.getListDates(r.listId);r.startDate=s.from,r.endDate=s.to}return new Promise((s,a)=>{const n=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).put(r);n.onerror=()=>{a(new Error("Failed to update task"))},n.onsuccess=()=>{s({...r,id:n.result})}})}getListDates(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Lists]).objectStore(o.Lists).get(t);a.onerror=()=>{s(new Error("Failed to get list for task"))},a.onsuccess=()=>{const n=a.result;r({from:n.startDate,to:n.endDate})}})}remove(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).delete(t);a.onerror=()=>{s(new p("Failed to remove task"))},a.onsuccess=()=>{r(null)}})}async getAll(t){let r=t.sortByPriority?"priority":"createdDate",s=t.sortByPriority?"next":"prev";t.sortByCompletion&&(r="status",s="next");const a=[],i=await new Promise((u,l)=>{const d=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index(r).openCursor(null,s);d.onerror=()=>{l(new p("Failed to get tasks"))};const f={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let b=0;const m=t.offset||0,w=t.limit||50;let P=0,q=m;d.onsuccess=B=>{const A=B.target?.result;if(A){const y=A.value;let L=!!y.listId||y.isArchived||me(y);L&&(t.type===v.dateRange?L=Y.dateRange(y,t.dateRange||{from:"",to:""}):t.type===v.list?L=Y.list(y,t.listId||0):L=Y[t.type](y)),L&&q>0?(P++,q--,a.push(y.id)):L&&q===0&&(b<w&&(f.data.push(y),b++),a.push(y.id),P++),A.continue()}else f.pagination.page=m?Math.ceil(P/m):1,f.pagination.total=P,f.pagination.itemsPerPage=w,f.pagination.totalPages=Math.ceil(P/w),u(f)}}),c=await this.getAllTaskRecords(t.type,i.data,a.sort((u,l)=>u-l),t.activeList);return i.data=c.result,i.pagination.completed=c.completed,i}async getAllTaskRecords(t,r,s,a=!1){if(!r.length||![v.today,v.list].includes(t)||v.list===t&&!a)return{result:r,completed:0};const i=await new Promise((l,d)=>{const f=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("taskId").getAll(IDBKeyRange.upperBound(s[s.length-1]));f.onerror=()=>{d(new Error("Failed to add task record"))},f.onsuccess=()=>{l(f.result)}});let c=0;return{result:r.map(l=>{let d;return t===v.today?d=i.find(f=>f.taskId===l.id&&f.timestamp===D()):t===v.list&&(d=i.find(f=>f.taskId===l.id&&!!l.listId)),d?(l.status=d.status,l.statusUpdatedAt=d.timestamp,l.statusRecordId=d.id,d.status===T.Done&&c++):(l.status=T.Open,l.statusUpdatedAt=void 0,l.statusRecordId=void 0),l}),completed:c}}updateTaskRecord(t){if(!t.id)return delete t.id,t.timestamp||(t.timestamp=D()),new Promise((r,s)=>{try{const a=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).add(t);a.onerror=()=>{s(new Error("Failed to add task record"))},a.onsuccess=()=>{r({...t,id:a.result})}}catch(a){throw console.error(a),a}});if(!t.timestamp)throw new p("invalid timestamp");return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).put(t);a.onerror=()=>{s(new Error("Failed to update task record"))},a.onsuccess=()=>{r(t)}})}getAllByListId(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),n=[];a.onerror=()=>{s(new p(`Failed to tasks for id ${t}`))},a.onsuccess=i=>{const c=i.target.result;c?(c.value.listId===t&&n.push(c.value),c.continue()):r(n)}})}async removeTasksByListId(t){let r=!1;const s=[];try{const a=await this.getAllByListId(t);for(const n of a)try{await this.remove(n.id),s.push(n.id)}catch{r=!0}r&&new ge(he.TASK,"Failed to remove some tasks from the list",{},s)}catch{}return s}updateAllTasksForList(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),n=[];a.onerror=()=>{s(new p("Failed to update tasks for list"))},a.onsuccess=i=>{const c=i.target.result;if(c){const u=c.value;if(u.listId===t.id){n.push(c.value);const l={};t.endDate&&(l.endDate=t.endDate),t.startDate&&(l.startDate=t.endDate),c.update({...u,...l})}c.continue()}else r(null)}})}}class _e{constructor(t){this.indexRequest=t}add(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Reports],"readwrite").objectStore(o.Reports).add(t);a.onerror=()=>{if(a.error?.message.includes("constraint")||a.error?.message==="Key already exists in the object store."){s(new Fe(a.error?.message));return}s(new p("Failed to add new report"))},a.onsuccess=()=>{r(t)}})}async get(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Reports]).objectStore(o.Reports).get(t);a.onerror=()=>{s(new p("Failed to get report"))},a.onsuccess=()=>{r(a.result)}})}}class we{constructor(t){this.indexRequest=t,this.objectNames=o}objectNames}class Be extends we{get(){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();s.onerror=()=>{r(new p("Error retrieving settings"))},s.onsuccess=()=>{t(s.result[0])}})}add(t){return new Promise((r,s)=>{t.lastModifiedDate=Date.now();const a=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(t);a.onerror=()=>{s(new p("Error saving settings"))},a.onsuccess=()=>{r({...t,id:a.result})}})}update(t){return new Promise((r,s)=>{t.lastModifiedDate=Date.now();const a=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(t);a.onerror=()=>{s(new p("Error saving settings"))},a.onsuccess=()=>{r(t)}})}}class He extends we{async cleanupLists(){let t=!0,r=0;const s=await this.getAllInvalidLists();try{for(const a of s)try{r+=await this.cleanupTasks(a)}catch{t=!0}t&&new ge(he.TASK,"Failed to remove some tasks from the list",{})}catch{}return t||await this.deleteLists(s),{deletedLists:s.length,deletedTasks:r}}deleteLists(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction(this.objectNames.Lists,"readwrite").objectStore(this.objectNames.Lists).delete(t);a.onerror=()=>{s(new p("Failed to clean up old list"))},a.onsuccess=()=>{r(a.result)}})}async cleanupTasks(t){const r=await this.getAllInvalidTasks(t);return new Promise((s,a)=>{const n=this.indexRequest.result.transaction(this.objectNames.Tasks,"readwrite").objectStore(this.objectNames.Tasks).delete(r);n.onerror=()=>{a(new p("Error retrieving settings"))},n.onsuccess=()=>{s(r.length)}})}getAllInvalidTasks(t){return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).index("createdDate").openCursor();a.onerror=()=>{s(new Error("Failed to get invalid tasks"))};const n=[];a.onsuccess=i=>{const c=i.target?.result;if(c){const u=c.value;(t&&t===u.listId||!t&&!u.listId&&!me(u)&&!u.isArchived)&&n.push(u),c.continue()}else r(n.map(u=>u.id))}})}getAllInvalidLists(){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([o.Lists],"readonly").objectStore(o.Lists).index("createdDate").openCursor();s.onerror=()=>{r(new Error("Failed to get lists"))};const a=[];s.onsuccess=n=>{const i=n.target?.result;if(i){const c=i.value;(c.isDeleted||c.endDate<D()&&!c.isArchived)&&a.push(i.value),i.continue()}else t(a.map(c=>c.id))}})}}class Q{tasks;lists;indexRequest;reports;cleanup;settings;static instance;async hasDatabase(){return new Promise((t,r)=>{if(!this.indexRequest){r(new p("Database does not exist"));return}try{const s=this.indexRequest.result.transaction([o.Settings]).objectStore(o.Settings).getAll();s.onerror=()=>{r(new p("Error retrieving settings"))},s.onsuccess=()=>{t(!!s.result.length)}}catch(s){if(s.message.includes("The database connection is closing")){t(!1);return}r(new p(s.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((t,r)=>{const s=indexedDB.open("personalPlanner",13);s.onerror=()=>{r(new p("Cannot use IndexDB"))},s.onsuccess=()=>{const a=s.result;a.onerror=n=>{r(new p(`Database error: ${n.target?.errorCode}`))},this.indexRequest=s,t(s)},s.onupgradeneeded=a=>{const n=s.result;if(!n.objectStoreNames.contains(o.Lists)){const i=n.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});i.createIndex("description","description"),i.createIndex("createdDate","createdDate"),i.createIndex("lastModifiedDate","lastModifiedDate"),i.createIndex("startDate","startDate"),i.createIndex("endDate","endDate"),i.createIndex("isDeleted","isDeleted"),i.createIndex("isArchived","isArchived")}if(!n.objectStoreNames.contains(o.TaskRecords)){const i=n.createObjectStore(o.TaskRecords,{autoIncrement:!0,keyPath:"id"});i.createIndex("taskId","taskId"),i.createIndex("status","status"),i.createIndex("timestamp","timestamp")}if(a.oldVersion,n.objectStoreNames.contains(o.Reports)||n.createObjectStore(o.Reports,{keyPath:"date"}).createIndex("count","count"),!n.objectStoreNames.contains(o.Settings)){const i=n.createObjectStore(o.Settings,{keyPath:"id",autoIncrement:!0});i.createIndex("archive","archive"),i.createIndex("archiveFor","archiveFor"),i.createIndex("image","image"),i.createIndex("name","name"),i.createIndex("lastModifiedDate","lastModifiedDate"),i.createIndex("theme","theme")}if(!n.objectStoreNames.contains(o.Tasks)){const i=n.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"});i.createIndex("listId","listId"),i.createIndex("description","description"),i.createIndex("note","note"),i.createIndex("startTime","startTime"),i.createIndex("endTime","endTime"),i.createIndex("priority","priority"),i.createIndex("status","status"),i.createIndex("days","days"),i.createIndex("carryOver","carryOver"),i.createIndex("createdDate","createdDate"),i.createIndex("lastModifiedDate","lastModifiedDate"),i.createIndex("startDate","startDate"),i.createIndex("endDate","endDate"),i.createIndex("isDeleted","isDeleted"),i.createIndex("isArchived","isArchived")}}})}repositories(){if(!this.indexRequest)throw new p;return{tasks:this.tasks||new Ue(this.indexRequest),cleanup:this.cleanup||new He(this.indexRequest),lists:this.lists||new $e(this.indexRequest),reports:this.reports||new _e(this.indexRequest),settings:this.settings||new Be(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new Q,await this.instance.start()),this.instance}async clear(t){this.indexRequest&&this.indexRequest.result.transaction([t],"readwrite").objectStore(t).clear()}async delete(){return new Promise((t,r)=>{this.indexRequest?.result.close();const s=indexedDB.deleteDatabase("personalPlanner");s.onerror=()=>{r(new p("Error deleting database."))},s.onsuccess=()=>{this.indexRequest=void 0,t(null)},s.onblocked=()=>{r(new p("Request is blocked"))}})}}const te={id:0,name:"",archive:!1,archiveFor:30,theme:"default"},et=ue("appStore",{state:()=>({isMobileLandscape:!1,isMobilePortrait:!1,isTabletLandscape:!1,isTabletPortrait:!1,device:{[E.isTabletPortrait]:!1,[E.isTabletLandscape]:!1,[E.isMobilePortrait]:!1,[E.isMobileLandscape]:!1},settings:te,globalLoading:!1}),getters:{isTablet(){return this.device.isTabletLandscape||this.device.isTabletPortrait},isMobile(){return this.device.isMobileLandscape||this.device.isMobilePortrait}},actions:{setMediaMatch(e,t){this.device[e]=t},async getSettings(e=!1){!e&&this.settings.id!==0||(this.settings=await this.$api.service.getSettings())},async updateSettings(e){this.settings=await this.$api.service.updateSettings(e),this.getSettings(!0)},async deleteApp(){return this.settings=te,(await Q.getInstance()).delete()},async addSettings(e){this.settings=await this.$api.service.addSettings(e)},setGlobalLoading(e){this.globalLoading=e}}}),tt=({app:e})=>({$api:e.config.globalProperties.$api});export{E as D,v as F,Q as L,Ze as N,Oe as P,T,Qe as a,D as b,W as c,Je as d,Ge as e,U as f,$ as g,Ye as h,tt as i,Xe as o,ze as p,Ve as s,et as u};
