(function(){"use strict";class d extends Error{}class S extends Error{}class A extends Error{}class P extends Error{}class R extends Error{}const x={RECORD:"RECORD",TASK:"TASK"};class y extends Error{constructor(e,t,r,s){super(t,r),this.key=e,this.data=s}}class j{constructor(e){this.db=e}async deleteList(e){await this.db.lists.remove(e);const t=await this.db.tasks.removeTasksByListId(e);try{for(const r of t)await this.db.records.remove(r)}catch{throw new y(x.RECORD,"Failed to remove records of deleted tasks")}}async getList(e){const t=await this.db.lists.get(e);if(!t)throw new A;const r=await this.db.tasks.getByListId(e);return{...t,tasks:r}}async getAllList(e,t){return await this.db.lists.getAll({type:"valid",offset:e,limit:t})||[]}async getTaskForList(e,t,r){const s=await this.db.tasks.getByListId(e,t,r),a={data:[],pagination:s.pagination};return a.data=await this.enrichTaskWithRecords(s.data),a}async getHabits(e,t){return await this.db.tasks.getHabit(e,t)}async getTask(e){return await this.db.tasks.get(e)}async getCount(){const e=await this.db.lists.getAllValid(),t=(await this.db.tasks.getForToday(0,4)).pagination.total;return{listCount:e.length,todayTaskCount:t}}async getTodaysList(e,t){const r=await this.db.tasks.getForToday(e,t),s={data:[],pagination:r.pagination};return s.data=await this.enrichTaskWithRecords(r.data),s}async getTomorrowsList(e,t){return await this.db.tasks.getForTomorrow(e,t)}async getNext3DaysUpcoming(){return await this.db.tasks.getNext3DaysAfterTomorrow()}async getUpcoming(e,t){return await this.db.tasks.getAllUpcoming(e,t)}async enrichTaskWithRecords(e){const t=e.map(a=>a.id),r=await this.db.records.getAll(t)||[];return e.map(a=>{const n=r.find(o=>o.taskId===a.id);return{...a,record:n}})}async deleteTask(e){await this.db.tasks.remove(e);try{const t=await this.db.records.getAll([e]);for(const r of t)await this.db.records.remove(r.id)}catch(t){throw new y(x.TASK,t.message)}}async updateTask(e){return await this.db.tasks.update(e)}async updateList(e){await this.db.lists.update(e),await this.db.tasks.updateAllTasksForList(e)}getRecentLists(){return this.db.lists.getRecent()}async updateRecord(e,t,r){if(r){const s=this.db.records.get(r);return await this.db.records.update(e,t,r),{...s,status:t}}return await this.db.records.add({taskId:e,status:t})}async addTask(e){return await this.db.tasks.add(e)}async addList(e){return await this.db.lists.add(e)}async addRecord(e){return await this.db.records.add(e)}async cleanOldRecords(){const t=(await this.db.lists.getAllInvalid()).map(a=>a.id);for(const a of t)await this.deleteList(a);const s=(await this.db.tasks.getAllInvalid()).map(a=>a.id);for(const a of s)await this.deleteTask(a)}async getSettings(){return await this.db.settings.get()}async updateSettings(e){const r={...await this.getSettings(),...e};return await this.db.settings.update(r)}async addSettings(e){return await this.db.settings.add(e)}}const k=60*60*24*1e3,u=()=>new Date().toISOString().split("T")[0],p=()=>new Date(Date.now()+k).toISOString().split("T")[0],b=(c,e)=>{const t=e?new Date(e).getTime():Date.now();return new Date(t+k*c).toISOString().split("T")[0]},L=c=>new Date(c).toISOString().split("T")[0],q=(c,e={},t)=>(c=c instanceof Date?c:new Date(c),new Intl.DateTimeFormat("en-US",e).format(c)),I=(c,e)=>{const t=new Set;let r=c;for(;r<=e;){const s=q(r,{weekday:"short"}).toLowerCase();if(t.add(s),r=b(1,r),t.size===7)break}return t};var l=(c=>(c[c.Active=1]="Active",c[c.Deleted=2]="Deleted",c[c.InActive=3]="InActive",c[c.Archive=4]="Archive",c))(l||{}),T=(c=>(c[c.Open=1]="Open",c[c.Progress=2]="Progress",c[c.Done=3]="Done",c))(T||{});const i={Lists:"lists",Tasks:"tasks",Settings:"appSettings",Records:"records",Reports:"reports"};class F{constructor(e){this.indexRequest=e}getAll(e){return new Promise((t,r)=>{let s;e?s=this.indexRequest.result.transaction([i.Records],"readwrite").objectStore(i.Records).openCursor():s=this.indexRequest.result.transaction([i.Records],"readwrite").objectStore(i.Records).getAll(),s.onerror=()=>{r(new d("Failed to get task records"))};const a=[];s.onsuccess=n=>{if(e){const o=n.target.result;if(o){const h=o.value;L(h.lastModifiedDate)===u()&&e.includes(h.taskId)&&a.push(o.value),o.continue()}else t(a);return}t(s.result||[])}})}get(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Records],"readwrite").objectStore(i.Records).get(e);s.onerror=()=>{r(new d("Failed to get task record"))},s.onsuccess=()=>{t(s.result)}})}remove(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Records],"readwrite").objectStore(i.Records).delete(e);s.onerror=()=>{r(new d("Failed to delete task record"))},s.onsuccess=()=>{t(null)}})}add(e){return new Promise((t,r)=>{const s=Object.assign({},e,{lastModifiedDate:Date.now()}),a=this.indexRequest.result.transaction([i.Records],"readwrite").objectStore(i.Records).add(s);a.onerror=()=>{if(a.error?.message.includes("constraint")){r(new R);return}r(new d("Failed to add new task record"))},a.onsuccess=()=>{t({...s,id:a.result})}})}async update(e,t,r){const s=Object.assign({},await this.get(r),{lastModifiedDate:Date.now()},{status:t});return new Promise((a,n)=>{s.taskId!==e&&n(new P);const o=this.indexRequest.result.transaction([i.Records],"readwrite").objectStore(i.Records).put(s);o.onerror=()=>{n(new d("Failed to update task record"))},o.onsuccess=()=>{a(o.result)}})}}class E{constructor(e){this.indexRequest=e}getAllCount(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).index("createdDate").getAll();s.onerror=()=>{r(new d("Failed to retreive list count"))},s.onsuccess=()=>{const a=s.result;e==="valid"&&t(a.filter(n=>e==="valid"&&n.status!==l.Archive&&n.endDate>=u()).length),e==="invalid"&&t(a.filter(n=>e==="invalid"&&n.status!==l.Archive&&n.endDate<u()).length),e==="archive"&&t(a.filter(n=>e==="archive"&&n.status===l.Archive).length)}})}getAll(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).index("createdDate").openCursor(null,"prev");s.onerror=()=>{r(new Error("Failed to get lists"))};const a=e.offset||0,n=e.limit||50;let o=0,h=a>0;const w=async()=>{const D=await this.getAllCount(e.type);return{itemsPerPage:n,total:D,totalPages:Math.ceil(D/n),page:a?D/a:1}},f={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};s.onsuccess=async D=>{const g=D.target?.result;if(g&&h)h=!1,g.advance(a+1);else if(g){o>=n&&(f.pagination=await w(),t(f));const m=g.value,V=e.type==="valid"&&m.status!==l.Archive&&m.endDate>=u(),K=e.type==="invalid"&&m.status!==l.Archive&&m.endDate<u(),U=e.type==="archive"&&m.status!==l.Archive;(V||K||U)&&(m.startDate<=u()&&m.status!==l.Archive&&(g.value.status=l.Active),f.data.push(g.value),o++),g.continue()}else f.pagination=await w(),t(f)}})}getAllValid(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).index("createdDate").openCursor();r.onerror=()=>{t(new Error("Failed to get lists"))};const s=[];r.onsuccess=a=>{const n=a.target?.result;n?(n.value.endDate>=u()&&(n.value.startDate<=u()&&(n.value.status=l.Active),s.push(n.value)),n.continue()):e(s)}})}getRecent(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).index("createdDate").openCursor(null,"prev");r.onerror=()=>{t(new Error("Failed to get lists"))};const s=[];let a=0;r.onsuccess=n=>{const o=n.target?.result;o&&a<5?(o.value.endDate>=u()&&(o.value.startDate<=u()&&(o.value.status=l.Active),s.push(o.value),a++),o.continue()):e(s)}})}getAllInvalid(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).index("createdDate").openCursor();r.onerror=()=>{t(new Error("Failed to get lists"))};const s=[];r.onsuccess=a=>{const n=a.target?.result;if(n){const o=n.value;o.endDate<u()&&o.status!==l.Archive&&s.push(n.value),n.continue()}else e(s)}})}add(e){return new Promise((t,r)=>{const s=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),archiveDate:0});(!s.endDate||!s.startDate||s.startDate>s.endDate)&&r(new S("Start and end dates are required and should be valid")),s.status!==l.Archive&&s.startDate&&e.startDate<=u()?s.status=l.Active:s.status!==l.Archive&&(s.status=l.InActive);const a=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).add(s);a.onerror=()=>{r(new Error("Failed to get lists"))},a.onsuccess=()=>{t({...s,id:a.result})}})}async update(e){const t=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).put(t);a.onerror=()=>{s(new Error("Failed to update list"))},a.onsuccess=()=>{r(a.result)}})}get(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).get(e);s.onerror=()=>{r(new Error("Failed to get lists"))},s.onsuccess=()=>{t(s.result)}})}remove(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Lists],"readwrite").objectStore(i.Lists).delete(e);s.onerror=()=>{r(new Error("Failed to remove list"))},s.onsuccess=()=>{t(null)}})}}function C(c,e){const t=new Set,r=[];for(const s of c)t.add(s);for(const s of e)t.has(s)&&r.push(s);return r}class O{constructor(e){this.indexRequest=e}isTaskDateValid(e){return(e.days.length||e.listId)&&(!e.endDate||e.endDate>=u())||!e.days.length&&e.startDate>=u()}isTaskValid(e,t,r=!1){return!t&&r?!0:t?(e.days.length||e.listId)&&(!e.endDate||e.endDate>=t.to)||!e.days.length&&e.startDate>=t.from&&e.startDate<=t.to:this.isTaskDateValid(e)}getIntersectingDays(e,t){const r=e.days.length?e.days:[q(e.startDate,{weekday:"short"}).toLowerCase()];return C([...I(t.from,t.to)],r)}getAllInternal(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).index("createdDate").getAll();s.onerror=()=>{r(new d("Failed to get tasks"))},s.onsuccess=()=>{const a=s.result;if(e.carryover){t(a.filter(n=>!!n.carryOver));return}t(a)}})}getBaseAll(e,t,r){return new Promise((s,a)=>{const n=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).index("createdDate").openCursor(null,"prev");n.onerror=()=>{a(new d("Failed to get tasks"))};const o={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let h=0,w=e,f=e>0;n.onsuccess=D=>{const g=D.target?.result;if(g&&f){f=!1,g.advance(e+1);return}if(g&&!f){const m=g.value;r(m)&&(h<t&&(o.data.push(m),h++),w++),g.continue()}else o.pagination.page=e?Math.ceil(w/e):1,o.pagination.total=w,o.pagination.itemsPerPage=t,o.pagination.totalPages=Math.ceil(w/t),s(o)}})}async getHabit(e=0,t=50){const r=s=>!!s.days.length&&(!s.endDate||s.endDate>=u());return this.getBaseAll(e,t,r)}async getForTomorrow(e=0,t=50){const r=s=>s.listId?!1:s.days.length?(!s.endDate||s.endDate>=p())&&!!this.getIntersectingDays(s,{to:p(),from:p()}).length:s.startDate===p();return this.getBaseAll(e,t,r)}async getForToday(e=0,t=50){const r=await this.getRecordTaskIds(),s=a=>a.listId?!1:a.carryOver&&!r.includes(a.id)?!0:a.days.length?(!a.endDate||a.endDate>=u())&&!!this.getIntersectingDays(a,{to:u(),from:u()}).length:a.startDate===u();return this.getBaseAll(e,t,s)}async getAllUpcoming(e=0,t=50){const r=s=>s.listId||s.days.length?!1:s.startDate>=p();return this.getBaseAll(e,t,r)}getNext3DaysAfterTomorrow(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).index("createdDate").openCursor(null,"prev");r.onerror=()=>{t(new d("Failed to get tasks"))};const s={from:b(2),to:b(4)},a=I(s.from,s.to),n=new Map;for(const o of a)n.set(o,[]);r.onsuccess=async o=>{try{const h=o.target?.result;if(h){const w=h.value;this.isTaskValid(w,s)&&this.getIntersectingDays(w,s).forEach(D=>{if(n.has(D)){const g=n.get(D)||[];n.set(D,[...g,w])}}),h.continue()}else e(n)}catch{t(new d)}}})}get(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).get(e);s.onerror=()=>{r(new d("Failed to get task"))},s.onsuccess=()=>{t(s.result)}})}async add(e){const t=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:l.Active});if(t.listId){const r=await this.getListDates(t.listId);t.startDate=r.from,t.endDate=r.to}return new Promise((r,s)=>{t.startDate||(t.startDate=u());const a=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).add(t);a.onerror=()=>{s(new d("Failed to add new task"))},a.onsuccess=()=>{r({...t,id:a.result})}})}async update(e){const t=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);if(t.listId){const r=await this.getListDates(t.listId);t.startDate=r.from,t.endDate=r.to}return new Promise((r,s)=>{const a=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).put(t);a.onerror=()=>{s(new Error("Failed to update task"))},a.onsuccess=()=>{r({...t,id:a.result})}})}getListDates(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Lists]).objectStore(i.Lists).get(e);s.onerror=()=>{r(new Error("Failed to get list for task"))},s.onsuccess=()=>{const a=s.result;t({from:a.startDate,to:a.endDate})}})}remove(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).delete(e);s.onerror=()=>{r(new d("Failed to remove task"))},s.onsuccess=()=>{t(null)}})}async removeTasksByListId(e){let t=!1;const r=[];try{const s=await this.getAllByListId(e);for(const a of s)try{await this.remove(a.id),r.push(a.id)}catch{t=!0}t&&new y(x.TASK,"Failed to remove some tasks from the list",{},r)}catch{}return r}getByListId(e,t=0,r=50){const s=a=>a.listId===e;return this.getBaseAll(t,r,s)}getAllByListId(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).index("createdDate").openCursor(),a=[];s.onerror=()=>{r(new d(`Failed to tasks for id ${e}`))},s.onsuccess=n=>{const o=n.target.result;o?(o.value.listId===e&&a.push(o.value),o.continue()):t(a)}})}async getRecordTaskIds(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction([i.Records],"readwrite").objectStore(i.Records).getAll();r.onerror=()=>{t(new d("Failed to update tasks"))},r.onsuccess=()=>{const s=r.result;e(s.filter(a=>a.status===T.Done).map(a=>a.taskId).toSorted((a,n)=>a-n))}})}updateAllTasksForList(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).index("createdDate").openCursor(),a=[];s.onerror=()=>{r(new d("Failed to update tasks for list"))},s.onsuccess=n=>{const o=n.target.result;if(o){const h=o.value;if(h.listId===e.id){a.push(o.value);const w={};e.endDate&&(w.endDate=e.endDate),e.startDate&&(w.startDate=e.endDate),o.update({...h,...w})}o.continue()}else t(null)}})}getAllInvalid(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction([i.Tasks],"readwrite").objectStore(i.Tasks).index("createdDate").openCursor();r.onerror=()=>{t(new Error("Failed to get invalid tasks"))};const s=[];r.onsuccess=a=>{const n=a.target?.result;if(n){const o=n.value;o.days.length&&o.endDate&&o.endDate<u()&&s.push(o),!o.days.length&&!o.listId&&o.startDate<u()&&s.push(o),n.continue()}else e(s)}})}}class M{constructor(e){this.indexRequest=e}add(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Reports],"readwrite").objectStore(i.Reports).add(e);s.onerror=()=>{if(s.error?.message.includes("constraint")||s.error?.message==="Key already exists in the object store."){r(new R(s.error?.message));return}r(new d("Failed to add new report"))},s.onsuccess=()=>{t(e)}})}async get(e){return new Promise((t,r)=>{const s=this.indexRequest.result.transaction([i.Reports]).objectStore(i.Reports).get(e);s.onerror=()=>{r(new d("Failed to get report"))},s.onsuccess=()=>{t(s.result)}})}}class N{constructor(e){this.indexRequest=e,this.objectNames=i}objectNames}class B extends N{get(){return new Promise((e,t)=>{const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();r.onerror=()=>{t(new d("Error retrieving settings"))},r.onsuccess=()=>{e(r.result[0])}})}add(e){return new Promise((t,r)=>{e.lastModifiedDate=Date.now();const s=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(e);s.onerror=()=>{r(new d("Error saving settings"))},s.onsuccess=()=>{t({...e,id:s.result})}})}update(e){return new Promise((t,r)=>{e.lastModifiedDate=Date.now();const s=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(e);s.onerror=()=>{r(new d("Error saving settings"))},s.onsuccess=()=>{t(e)}})}}class v{tasks;lists;records;indexRequest;reports;settings;static instance;async hasDatabase(){return new Promise((e,t)=>{if(!this.indexRequest){t(new d("Database does not exist"));return}try{const r=this.indexRequest.result.transaction([i.Settings]).objectStore(i.Settings).getAll();r.onerror=()=>{t(new d("Error retrieving settings"))},r.onsuccess=()=>{e(!!r.result.length)}}catch(r){if(r.message.includes("The database connection is closing")){e(!1);return}t(new d(r.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((e,t)=>{const r=indexedDB.open("personalPlanner",13);r.onerror=()=>{t(new d("Cannot use IndexDB"))},r.onsuccess=()=>{const s=r.result;s.onerror=a=>{t(new d(`Database error: ${a.target?.errorCode}`))},this.indexRequest=r,e(r)},r.onupgradeneeded=s=>{const a=r.result;if(!a.objectStoreNames.contains(i.Lists)){const n=a.createObjectStore(i.Lists,{autoIncrement:!0,keyPath:"id"});n.createIndex("description","description"),n.createIndex("createdDate","createdDate"),n.createIndex("lastModifiedDate","lastModifiedDate"),n.createIndex("startDate","startDate"),n.createIndex("endDate","endDate"),n.createIndex("status","status"),n.createIndex("archiveDate","archiveDate")}if(s.oldVersion,!a.objectStoreNames.contains(i.Records)){const n=a.createObjectStore(i.Records,{autoIncrement:!0,keyPath:"id"});n.createIndex("taskId","taskId"),n.createIndex("status","status"),n.createIndex("lastModifiedDate","lastModifiedDate")}if(a.objectStoreNames.contains(i.Reports)||a.createObjectStore(i.Reports,{keyPath:"date"}).createIndex("count","count"),!a.objectStoreNames.contains(i.Settings)){const n=a.createObjectStore(i.Settings,{keyPath:"id",autoIncrement:!0});n.createIndex("archive","archive"),n.createIndex("archiveFor","archiveFor"),n.createIndex("image","image"),n.createIndex("name","name"),n.createIndex("lastModifiedDate","lastModifiedDate")}if(!a.objectStoreNames.contains(i.Tasks)){const n=a.createObjectStore(i.Tasks,{autoIncrement:!0,keyPath:"id"});n.createIndex("listId","listId"),n.createIndex("description","description"),n.createIndex("note","note"),n.createIndex("startTime","startTime"),n.createIndex("endTime","endTime"),n.createIndex("priority","priority"),n.createIndex("status","status"),n.createIndex("days","days"),n.createIndex("carryOver","carryOver"),n.createIndex("createdDate","createdDate"),n.createIndex("lastModifiedDate","lastModifiedDate"),n.createIndex("startDate","startDate"),n.createIndex("endDate","endDate"),n.createIndex("archiveDate","archiveDate"),n.createIndex("isDeleted","isDeleted"),n.createIndex("isArchived","isArchived")}}})}repositories(){if(!this.indexRequest)throw new d;return{tasks:this.tasks||new O(this.indexRequest),lists:this.lists||new E(this.indexRequest),records:this.records||new F(this.indexRequest),reports:this.reports||new M(this.indexRequest),settings:this.settings||new B(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new v,await this.instance.start()),this.instance}async clear(e){this.indexRequest&&this.indexRequest.result.transaction([e],"readwrite").objectStore(e).clear()}async delete(){return new Promise((e,t)=>{this.indexRequest?.result.close();const r=indexedDB.deleteDatabase("personalPlanner");r.onerror=()=>{t(new d("Error deleting database."))},r.onsuccess=()=>{this.indexRequest=void 0,e(null)},r.onblocked=()=>{t(new d("Request is blocked"))}})}}onmessage=async function(c){console.info(c.data);const e=await v.getInstance();try{await new j(e.repositories()).cleanOldRecords(),this.postMessage("clean up completed")}catch{}}})();
