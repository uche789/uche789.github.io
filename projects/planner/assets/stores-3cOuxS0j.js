import{H as ie,r as ae,I as ne,J as oe,c as ce,K as F,L as Z,M as xe,b as Te,N as Se,O as Re,w as Pe,n as Le,P as Ie,i as qe,Q as je}from"./RichEditor-DMhdOr4s.js";function J(t,e={},s){for(const r in t){const i=t[r],a=s?`${s}:${r}`:r;typeof i=="object"&&i!==null?J(i,e,a):typeof i=="function"&&(e[a]=i)}return e}const _e={run:t=>t()},Oe=()=>_e,le=typeof console.createTask<"u"?console.createTask:Oe;function Ae(t,e){const s=e.shift(),r=le(s);return t.reduce((i,a)=>i.then(()=>r.run(()=>a(...e))),Promise.resolve())}function Ce(t,e){const s=e.shift(),r=le(s);return Promise.all(t.map(i=>r.run(()=>i(...e))))}function W(t,e){for(const s of[...t])s(e)}class Me{constructor(){this._hooks={},this._before=void 0,this._after=void 0,this._deprecatedMessages=void 0,this._deprecatedHooks={},this.hook=this.hook.bind(this),this.callHook=this.callHook.bind(this),this.callHookWith=this.callHookWith.bind(this)}hook(e,s,r={}){if(!e||typeof s!="function")return()=>{};const i=e;let a;for(;this._deprecatedHooks[e];)a=this._deprecatedHooks[e],e=a.to;if(a&&!r.allowDeprecated){let n=a.message;n||(n=`${i} hook has been deprecated`+(a.to?`, please use ${a.to}`:"")),this._deprecatedMessages||(this._deprecatedMessages=new Set),this._deprecatedMessages.has(n)||(console.warn(n),this._deprecatedMessages.add(n))}if(!s.name)try{Object.defineProperty(s,"name",{get:()=>"_"+e.replace(/\W+/g,"_")+"_hook_cb",configurable:!0})}catch{}return this._hooks[e]=this._hooks[e]||[],this._hooks[e].push(s),()=>{s&&(this.removeHook(e,s),s=void 0)}}hookOnce(e,s){let r,i=(...a)=>(typeof r=="function"&&r(),r=void 0,i=void 0,s(...a));return r=this.hook(e,i),r}removeHook(e,s){if(this._hooks[e]){const r=this._hooks[e].indexOf(s);r!==-1&&this._hooks[e].splice(r,1),this._hooks[e].length===0&&delete this._hooks[e]}}deprecateHook(e,s){this._deprecatedHooks[e]=typeof s=="string"?{to:s}:s;const r=this._hooks[e]||[];delete this._hooks[e];for(const i of r)this.hook(e,i)}deprecateHooks(e){Object.assign(this._deprecatedHooks,e);for(const s in e)this.deprecateHook(s,e[s])}addHooks(e){const s=J(e),r=Object.keys(s).map(i=>this.hook(i,s[i]));return()=>{for(const i of r.splice(0,r.length))i()}}removeHooks(e){const s=J(e);for(const r in s)this.removeHook(r,s[r])}removeAllHooks(){for(const e in this._hooks)delete this._hooks[e]}callHook(e,...s){return s.unshift(e),this.callHookWith(Ae,e,...s)}callHookParallel(e,...s){return s.unshift(e),this.callHookWith(Ce,e,...s)}callHookWith(e,s,...r){const i=this._before||this._after?{name:s,args:r,context:{}}:void 0;this._before&&W(this._before,i);const a=e(s in this._hooks?[...this._hooks[s]]:[],r);return a instanceof Promise?a.finally(()=>{this._after&&i&&W(this._after,i)}):(this._after&&i&&W(this._after,i),a)}beforeEach(e){return this._before=this._before||[],this._before.push(e),()=>{if(this._before!==void 0){const s=this._before.indexOf(e);s!==-1&&this._before.splice(s,1)}}}afterEach(e){return this._after=this._after||[],this._after.push(e),()=>{if(this._after!==void 0){const s=this._after.indexOf(e);s!==-1&&this._after.splice(s,1)}}}}function Xe(){return new Me}/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */let de;const $=t=>de=t,ue=Symbol();function z(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var E;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(E||(E={}));function et(){const t=ie(!0),e=t.run(()=>ae({}));let s=[],r=[];const i=ne({install(a){$(i),i._a=a,a.provide(ue,i),a.config.globalProperties.$pinia=i,r.forEach(n=>s.push(n)),r=[]},use(a){return this._a?s.push(a):r.push(a),this},_p:s,_a:null,_e:t,_s:new Map,state:e});return i}const he=()=>{};function X(t,e,s,r=he){t.push(e);const i=()=>{const a=t.indexOf(e);a>-1&&(t.splice(a,1),r())};return!s&&Se()&&Re(i),i}function j(t,...e){t.slice().forEach(s=>{s(...e)})}const Ee=t=>t(),ee=Symbol(),K=Symbol();function Q(t,e){t instanceof Map&&e instanceof Map?e.forEach((s,r)=>t.set(r,s)):t instanceof Set&&e instanceof Set&&e.forEach(t.add,t);for(const s in e){if(!e.hasOwnProperty(s))continue;const r=e[s],i=t[s];z(i)&&z(r)&&t.hasOwnProperty(s)&&!F(r)&&!Z(r)?t[s]=Q(i,r):t[s]=r}return t}const Fe=Symbol();function He(t){return!z(t)||!Object.prototype.hasOwnProperty.call(t,Fe)}const{assign:L}=Object;function Ne(t){return!!(F(t)&&t.effect)}function $e(t,e,s,r){const{state:i,actions:a,getters:n}=e,c=s.state.value[t];let u;function l(){c||(s.state.value[t]=i?i():{});const d=Ie(s.state.value[t]);return L(d,a,Object.keys(n||{}).reduce((g,b)=>(g[b]=ne(ce(()=>{$(s);const m=s._s.get(t);return n[b].call(m,m)})),g),{}))}return u=fe(t,l,e,s,r,!0),u}function fe(t,e,s={},r,i,a){let n;const c=L({actions:{}},s),u={deep:!0};let l,d,g=[],b=[],m;const w=r.state.value[t];!a&&!w&&(r.state.value[t]={}),ae({});let R;function I(f){let h;l=d=!1,typeof f=="function"?(f(r.state.value[t]),h={type:E.patchFunction,storeId:t,events:m}):(Q(r.state.value[t],f),h={type:E.patchObject,payload:f,storeId:t,events:m});const D=R=Symbol();Le().then(()=>{R===D&&(l=!0)}),d=!0,j(g,h,r.state.value[t])}const U=a?function(){const{state:h}=s,D=h?h():{};this.$patch(q=>{L(q,D)})}:he;function _(){n.stop(),g=[],b=[],r._s.delete(t)}const y=(f,h="")=>{if(ee in f)return f[K]=h,f;const D=function(){$(r);const q=Array.from(arguments),A=[],B=[];function ye(x){A.push(x)}function De(x){B.push(x)}j(b,{args:q,name:D[K],store:S,after:ye,onError:De});let C;try{C=f.apply(this&&this.$id===t?this:S,q)}catch(x){throw j(B,x),x}return C instanceof Promise?C.then(x=>(j(A,x),x)).catch(x=>(j(B,x),Promise.reject(x))):(j(A,C),C)};return D[ee]=!0,D[K]=h,D},P={_p:r,$id:t,$onAction:X.bind(null,b),$patch:I,$reset:U,$subscribe(f,h={}){const D=X(g,f,h.detached,()=>q()),q=n.run(()=>Pe(()=>r.state.value[t],A=>{(h.flush==="sync"?d:l)&&f({storeId:t,type:E.direct,events:m},A)},L({},u,h)));return D},$dispose:_},S=Te(P);r._s.set(t,S);const O=(r._a&&r._a.runWithContext||Ee)(()=>r._e.run(()=>(n=ie()).run(()=>e({action:y}))));for(const f in O){const h=O[f];if(F(h)&&!Ne(h)||Z(h))a||(w&&He(h)&&(F(h)?h.value=w[f]:Q(h,w[f])),r.state.value[t][f]=h);else if(typeof h=="function"){const D=y(h,f);O[f]=D,c.actions[f]=h}}return L(S,O),L(oe(S),O),Object.defineProperty(S,"$state",{get:()=>r.state.value[t],set:f=>{I(h=>{L(h,f)})}}),r._p.forEach(f=>{L(S,n.run(()=>f({store:S,app:r._a,pinia:r,options:c})))}),w&&a&&s.hydrate&&s.hydrate(S.$state,w),l=!0,d=!0,S}/*! #__NO_SIDE_EFFECTS__ */function ge(t,e,s){let r;const i=typeof e=="function";r=i?s:e;function a(n,c){const u=je();return n=n||(u?qe(ue,null):null),n&&$(n),n=de,n._s.has(t)||(i?fe(t,e,r,n):$e(t,r,n)),n._s.get(t)}return a.$id=t,a}function tt(t){const e=oe(t),s={};for(const r in e){const i=e[r];i.effect?s[r]=ce({get:()=>t[r],set(a){t[r]=a}}):(F(i)||Z(i))&&(s[r]=xe(t,r))}return s}const st={mon:"Monday",tue:"Tuesday",wed:"Wednesday",thu:"Thursday",fri:"Friday",sat:"Saturday",sun:"Sunday"};var T=(t=>(t[t.Open=1]="Open",t[t.Progress=2]="Progress",t[t.Done=3]="Done",t))(T||{}),Ue=(t=>(t[t.High=1]="High",t[t.Medium=2]="Medium",t[t.Normal=3]="Normal",t[t.Trivial=4]="Trivial",t))(Ue||{});const rt={1:"High",2:"Medium",3:"Normal",4:"Trivial"};var k=(t=>(t.list="list",t.dateRange="dateRange",t.tomorrow="tomorrow",t.today="today",t.upcoming="upcoming",t.habits="habits",t.archived="archived",t))(k||{});const o={Lists:"lists",Tasks:"tasks",Settings:"appSettings",Reports:"reports",TaskRecords:"taskRecords"},it=ge("tasks",{state:()=>({pageListId:0,lists:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},habits:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},todaysTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},allUpcomingTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},tomorrowsTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},selectedListTasks:{data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},recentList:[],updatingState:{list:!1,habit:!1,task:!1},currentSelectedTask:{taskItem:null,records:[]}}),getters:{selectedPageList(){return this.lists.data.find(t=>t.id===this.pageListId)},countTodaysTask(){return this.todaysTasks.pagination.total},countList(){return this.lists.pagination.total}},actions:{async getTodaysTasks(t=1,e=!1,s=!1){const i=10*t-10;this.todaysTasks=await this.$api.service.getTodaysList(i,10,e,s)},async getTomorrowTasks(t=1,e=!1){const r=7*t-7;this.tomorrowsTasks=await this.$api.service.getTomorrowsList(r,7,e)},async getUpcoming(t=1,e=!1){const r=20*t-20;this.allUpcomingTasks=await this.$api.service.getUpcoming(r,20,e)},async getAllList(t=1){const s=50*t-50;this.lists=await this.$api.service.getAllList(s,50)},async getCount(){this.getAllList(),this.getTodaysTasks()},async addList(t){return await this.$api.service.addList(t)},async getList(t){let e=this.lists.data.findIndex(s=>s.id===t);if(e===-1){const s=await this.$api.service.getList(t);this.lists.data.push(s),e=this.lists.data.length-1}return this.lists.data[e]},async getTaskForList(t,e=1,s=!1,r=!1){const a=20*e-20;this.selectedListTasks=await this.$api.service.getTaskForList(t,a,20,s,r)},async deleteList(t){await this.$api.service.deleteList(t),this.recentList=this.recentList.filter(e=>e.id!==t)},async updateList(t){const e=this.lists.data.findIndex(s=>s.id===t.id);await this.$api.service.updateList(t),this.lists.data[e]={...this.lists.data[e],...t}},setPageListId(t){this.pageListId=t},async getHabits(t=1,e=!1){const r=20*t-20;this.habits=await this.$api.service.getHabits(r,20,e)},async addTask(t){await this.$api.service.addTask(t)},async updateTask(t){const e=await this.$api.service.updateTask(t);if(t.listId){let s=this.selectedListTasks.data.find(r=>r.id===t.id);if(s){s={...s,...e};return}}},async changeTaskStatus(t,e){const s=()=>e||(!e&&e===T.Open?T.Done:!e&&t.status===T.Done?T.Open:T.Done),r=await this.$api.service.updateTask({id:t.id,status:s(),statusRecordId:t.statusRecordId,statusUpdatedAt:t.statusUpdatedAt},!0);return t.statusRecordId=r.statusRecordId,t.status=r.status,t.statusUpdatedAt=r.statusUpdatedAt,e},async deleteTask(t){await this.$api.service.deleteTask(t)},async getRecentList(){this.recentList=(await this.$api.service.getRecentLists()).data},async setUpdatingState(t,e){this.updatingState[t]=e},async getCurrentlySelectedTast(t){this.currentSelectedTask.taskItem=await this.$api.service.getTask(t),this.currentSelectedTask.taskItem.days.length>0&&(this.currentSelectedTask.records=await this.$api.service.getHabitRecords(t))}}});var M=(t=>(t.isTabletPortrait="isTabletPortrait",t.isTabletLandscape="isTabletLandscape",t.isMobilePortrait="isMobilePortrait",t.isMobileLandscape="isMobileLandscape",t))(M||{});class p extends Error{}class Be extends Error{}class at extends Error{}class We extends Error{}const pe={RECORD:"RECORD",TASK:"TASK"};class me extends Error{constructor(e,s,r,i){super(s,r),this.key=e,this.data=i}}const we=3600*24*1e3;function H(t){const e=t.getUTCMonth()+1,s=t.getUTCDate();return`${t.getUTCFullYear()}-${e<10?"0"+e:e}-${s<10?"0"+s:s}`}const v=()=>H(new Date),nt=t=>{let e;return e=new Date,{fullYear:e.getUTCFullYear(),month:Number(N(e,{month:"numeric"})),monthString:N(e,{month:"long"}),numberOfDays:new Date(e.getUTCFullYear(),e.getUTCMonth()+1,0).getDate()}},Ke=t=>(t=typeof t=="string"?new Date(t):t,{from:H(new Date(t.getUTCFullYear(),t.getUTCMonth(),1)),to:H(new Date(t.getUTCFullYear(),t.getUTCMonth()+1,0))}),Y=()=>H(new Date(Date.now()+we)),be=(t,e)=>{const s=e?new Date(e).getTime():Date.now();return H(new Date(s+we*t))},N=(t,e={},s)=>(t=t instanceof Date?t:new Date(t),new Intl.DateTimeFormat("en-US",{...e,timeZone:"UTC"}).format(t)),te=(t,e)=>{const s=new Set;let r=t;for(;r<=e;){const i=N(r,{weekday:"short"}).toLowerCase();if(s.add(i),r=be(1,r),s.size===7)break}return s};class Ye{constructor(e){this.indexRequest=e}getAllCount(e="valid"){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").getAll();i.onerror=()=>{r(new p("Failed to retreive list count"))},i.onsuccess=()=>{const a=i.result;e==="valid"&&s(a.filter(n=>e==="valid"&&n.isDeleted!==!1&&n.endDate>=v()).length),e==="archived"&&s(a.filter(n=>e==="archived"&&n.isArchived&&!n.isDeleted).length)}})}getAll(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").openCursor(null,"prev");i.onerror=()=>{r(new Error("Failed to get lists"))};const a={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},n=e.offset||0,c=e.limit||50;let u=0,l=n>0,d=0;i.onsuccess=async g=>{const b=g.target?.result;if(b&&l){l=!1,b.advance(n+1);return}if(b&&!l){e.type==="recent"&&u===4&&s(a);const m=b.value;let w=(m.isArchived||m.endDate>=v())&&!m.isDeleted;w&&e.type==="archived"&&(w=m.isArchived),w=w&&(!e.getOnlyActive||e.getOnlyActive&&m.startDate>v()),w&&(u<c&&(a.data.push(m),u++),d++),b.continue()}else a.pagination.page=n?Math.ceil(d/n):1,a.pagination.total=d,a.pagination.itemsPerPage=c,a.pagination.totalPages=Math.ceil(d/c),s(a)}})}add(e){return new Promise((s,r)=>{const i=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),isArchived:!1,isDeleted:!1});(!i.endDate||!i.startDate||i.startDate>i.endDate)&&r(new Be("Start and end dates are required and should be valid"));const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).add(i);a.onerror=()=>{r(new Error("Failed to get lists"))},a.onsuccess=()=>{s({...i,id:a.result})}})}async update(e){const s=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);return new Promise((r,i)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).put(s);a.onerror=()=>{i(new Error("Failed to update list"))},a.onsuccess=()=>{r(a.result)}})}get(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).get(e);i.onerror=()=>{r(new Error("Failed to get lists"))},i.onsuccess=()=>{s(i.result)}})}remove(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).delete(e);i.onerror=()=>{r(new Error("Failed to remove list"))},i.onsuccess=()=>{s(null)}})}}function se(t,e){const s=new Set,r=[];for(const i of t)s.add(i);for(const i of e)s.has(i)&&r.push(i);return r}function ot(t){const s=N(new Date,{hour12:!1,hour:"numeric",minute:"numeric"});return t>s}const ke=t=>t.status===T.Open&&t.carryOver&&t.startDate<v()||!!t.days.length&&(!t.endDate||!!t.endDate&&t.endDate>=v())||!t.days.length&&t.startDate>=v(),V={[k.habits]:t=>!!t.days.length,[k.archived]:t=>t.isArchived,[k.list]:(t,e)=>t.listId===e,[k.today]:t=>{const e=t.status===T.Open&&t.carryOver&&t.startDate<v();return!t.listId&&(e||t.startDate===v()&&!t.days.length||!!t.days.length&&!!se([...te(v(),v())],t.days).length)},[k.tomorrow]:t=>!t.listId&&(t.startDate===Y()||!!t.days.length&&!!se([...te(Y(),Y())],t.days).length),[k.upcoming]:t=>!t.listId&&t.startDate>=be(2),[k.dateRange]:(t,e)=>!t.listId&&(t.startDate>=e.from||t.startDate<=e.to)};class Ve{constructor(e){this.indexRequest=e}getHabitRecords(e,s){return new Promise((r,i)=>{const a=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("timestamp").openCursor(null,"prev"),n=s||Ke(new Date),c=[];a.onerror=()=>{i(new p("Failed to get habit records"))},a.onsuccess=u=>{const l=u.target?.result;if(l){const d=l.value;d.taskId===e&&d.timestamp&&d.timestamp>=n.from&&d.timestamp<=n.to&&c.push(d),l.continue()}else r(c)}})}get(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).get(e);i.onerror=()=>{r(new p("Failed to get task"))},i.onsuccess=()=>{s(i.result)}})}async add(e){const s=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:T.Open});if(s.listId){const r=await this.getListDates(s.listId);s.startDate=r.from,s.endDate=r.to}return new Promise((r,i)=>{s.startDate||(s.startDate=v());const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).add(s);a.onerror=()=>{i(new p("Failed to add new task"))},a.onsuccess=()=>{r({...s,id:a.result})}})}async update(e){const s=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);if(s.listId){const r=await this.getListDates(s.listId);s.startDate=r.from,s.endDate=r.to}return new Promise((r,i)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).put(s);a.onerror=()=>{i(new Error("Failed to update task"))},a.onsuccess=()=>{r({...s,id:a.result})}})}getListDates(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Lists]).objectStore(o.Lists).get(e);i.onerror=()=>{r(new Error("Failed to get list for task"))},i.onsuccess=()=>{const a=i.result;s({from:a.startDate,to:a.endDate})}})}remove(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).delete(e);i.onerror=()=>{r(new p("Failed to remove task"))},i.onsuccess=()=>{s(null)}})}async getAll(e){let s=e.sortByPriority?"priority":"createdDate",r=e.sortByPriority?"next":"prev";e.sortByCompletion&&(s="status",r="next");const i=[],n=await new Promise((u,l)=>{const d=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index(s).openCursor(null,r);d.onerror=()=>{l(new p("Failed to get tasks"))};const g={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let b=0;const m=e.offset||0,w=e.limit||50;let R=0,I=m;d.onsuccess=U=>{const _=U.target?.result;if(_){const y=_.value;let P=!!y.listId||y.isArchived||ke(y);P&&(e.type===k.dateRange?P=V.dateRange(y,e.dateRange||{from:"",to:""}):e.type===k.list?P=V.list(y,e.listId||0):P=V[e.type](y)),P&&I>0?(R++,I--,i.push(y.id)):P&&I===0&&(b<w&&(g.data.push(y),b++),i.push(y.id),R++),_.continue()}else g.pagination.page=m?Math.ceil(R/m):1,g.pagination.total=R,g.pagination.itemsPerPage=w,g.pagination.totalPages=Math.ceil(R/w),u(g)}}),c=await this.getAllTaskRecords(e.type,n.data,i.sort((u,l)=>u-l),e.activeList);return n.data=c.result,n.pagination.completed=c.completed,n}async getAllTaskRecords(e,s,r,i=!1){if(!s.length||![k.today,k.list].includes(e)||k.list===e&&!i)return{result:s,completed:0};const n=await new Promise((l,d)=>{const g=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("taskId").getAll(IDBKeyRange.upperBound(r[r.length-1]));g.onerror=()=>{d(new Error("Failed to add task record"))},g.onsuccess=()=>{l(g.result)}});let c=0;return{result:s.map(l=>{let d;return e===k.today?d=n.find(g=>g.taskId===l.id&&g.timestamp===v()):e===k.list&&(d=n.find(g=>g.taskId===l.id&&!!l.listId)),d?(l.status=d.status,l.statusUpdatedAt=d.timestamp,l.statusRecordId=d.id,d.status===T.Done&&c++):(l.status=T.Open,l.statusUpdatedAt=void 0,l.statusRecordId=void 0),l}),completed:c}}updateTaskRecord(e){if(!e.id)return delete e.id,e.timestamp||(e.timestamp=v()),new Promise((s,r)=>{try{const i=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).add(e);i.onerror=()=>{r(new Error("Failed to add task record"))},i.onsuccess=()=>{s({...e,id:i.result})}}catch(i){throw console.error(i),i}});if(!e.timestamp)throw new p("invalid timestamp");return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).put(e);i.onerror=()=>{r(new Error("Failed to update task record"))},i.onsuccess=()=>{s(e)}})}getAllByListId(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),a=[];i.onerror=()=>{r(new p(`Failed to tasks for id ${e}`))},i.onsuccess=n=>{const c=n.target.result;c?(c.value.listId===e&&a.push(c.value),c.continue()):s(a)}})}async removeTasksByListId(e){let s=!1;const r=[];try{const i=await this.getAllByListId(e);for(const a of i)try{await this.remove(a.id),r.push(a.id)}catch{s=!0}s&&new me(pe.TASK,"Failed to remove some tasks from the list",{},r)}catch{}return r}updateAllTasksForList(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),a=[];i.onerror=()=>{r(new p("Failed to update tasks for list"))},i.onsuccess=n=>{const c=n.target.result;if(c){const u=c.value;if(u.listId===e.id){a.push(c.value);const l={};e.endDate&&(l.endDate=e.endDate),e.startDate&&(l.startDate=e.endDate),c.update({...u,...l})}c.continue()}else s(null)}})}}class Je{constructor(e){this.indexRequest=e}add(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Reports],"readwrite").objectStore(o.Reports).add(e);i.onerror=()=>{if(i.error?.message.includes("constraint")||i.error?.message==="Key already exists in the object store."){r(new We(i.error?.message));return}r(new p("Failed to add new report"))},i.onsuccess=()=>{s(e)}})}async get(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Reports]).objectStore(o.Reports).get(e);i.onerror=()=>{r(new p("Failed to get report"))},i.onsuccess=()=>{s(i.result)}})}}class ve{constructor(e){this.indexRequest=e,this.objectNames=o}objectNames}class ze extends ve{get(){return new Promise((e,s)=>{const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();r.onerror=()=>{s(new p("Error retrieving settings"))},r.onsuccess=()=>{e(r.result[0])}})}add(e){return new Promise((s,r)=>{e.lastModifiedDate=Date.now();const i=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(e);i.onerror=()=>{r(new p("Error saving settings"))},i.onsuccess=()=>{s({...e,id:i.result})}})}update(e){return new Promise((s,r)=>{e.lastModifiedDate=Date.now();const i=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(e);i.onerror=()=>{r(new p("Error saving settings"))},i.onsuccess=()=>{s(e)}})}}class Qe extends ve{async cleanupLists(){let e=!0,s=0;const r=await this.getAllInvalidLists();try{for(const i of r)try{s+=await this.cleanupTasks(i)}catch{e=!0}e&&new me(pe.TASK,"Failed to remove some tasks from the list",{})}catch{}return e||await this.deleteLists(r),{deletedLists:r.length,deletedTasks:s}}deleteLists(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction(this.objectNames.Lists,"readwrite").objectStore(this.objectNames.Lists).delete(e);i.onerror=()=>{r(new p("Failed to clean up old list"))},i.onsuccess=()=>{s(i.result)}})}async cleanupTasks(e){const s=await this.getAllInvalidTasks(e);return new Promise((r,i)=>{const a=this.indexRequest.result.transaction(this.objectNames.Tasks,"readwrite").objectStore(this.objectNames.Tasks).delete(s);a.onerror=()=>{i(new p("Error retrieving settings"))},a.onsuccess=()=>{r(s.length)}})}getAllInvalidTasks(e){return new Promise((s,r)=>{const i=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).index("createdDate").openCursor();i.onerror=()=>{r(new Error("Failed to get invalid tasks"))};const a=[];i.onsuccess=n=>{const c=n.target?.result;if(c){const u=c.value;(e&&e===u.listId||!e&&!u.listId&&!ke(u)&&!u.isArchived)&&a.push(u),c.continue()}else s(a.map(u=>u.id))}})}getAllInvalidLists(){return new Promise((e,s)=>{const r=this.indexRequest.result.transaction([o.Lists],"readonly").objectStore(o.Lists).index("createdDate").openCursor();r.onerror=()=>{s(new Error("Failed to get lists"))};const i=[];r.onsuccess=a=>{const n=a.target?.result;if(n){const c=n.value;(c.isDeleted||c.endDate<v()&&!c.isArchived)&&i.push(n.value),n.continue()}else e(i.map(c=>c.id))}})}}class G{tasks;lists;indexRequest;reports;cleanup;settings;static instance;async hasDatabase(){return new Promise((e,s)=>{if(!this.indexRequest){s(new p("Database does not exist"));return}try{const r=this.indexRequest.result.transaction([o.Settings]).objectStore(o.Settings).getAll();r.onerror=()=>{s(new p("Error retrieving settings"))},r.onsuccess=()=>{e(!!r.result.length)}}catch(r){if(r.message.includes("The database connection is closing")){e(!1);return}s(new p(r.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((e,s)=>{const r=indexedDB.open("personalPlanner",14);r.onerror=()=>{s(new p("Cannot use IndexDB"))},r.onsuccess=()=>{const i=r.result;i.onerror=a=>{s(new p(`Database error: ${a.target?.errorCode}`))},this.indexRequest=r,e(r)},r.onupgradeneeded=i=>{const a=r.result;if(!a.objectStoreNames.contains(o.Lists)){const n=a.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});n.createIndex("description","description"),n.createIndex("createdDate","createdDate"),n.createIndex("lastModifiedDate","lastModifiedDate"),n.createIndex("startDate","startDate"),n.createIndex("endDate","endDate"),n.createIndex("isDeleted","isDeleted"),n.createIndex("isArchived","isArchived")}if(!a.objectStoreNames.contains(o.TaskRecords)){const n=a.createObjectStore(o.TaskRecords,{autoIncrement:!0,keyPath:"id"});n.createIndex("taskId","taskId"),n.createIndex("status","status"),n.createIndex("timestamp","timestamp")}if(a.objectStoreNames.contains(o.Reports)||a.createObjectStore(o.Reports,{keyPath:"date"}).createIndex("count","count"),!a.objectStoreNames.contains(o.Settings)){const n=a.createObjectStore(o.Settings,{keyPath:"id",autoIncrement:!0});n.createIndex("archive","archive"),n.createIndex("archiveFor","archiveFor"),n.createIndex("image","image"),n.createIndex("name","name"),n.createIndex("lastModifiedDate","lastModifiedDate"),n.createIndex("theme","theme")}if(!a.objectStoreNames.contains(o.Tasks)){const n=a.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"});n.createIndex("listId","listId"),n.createIndex("description","description"),n.createIndex("note","note"),n.createIndex("startTime","startTime"),n.createIndex("endTime","endTime"),n.createIndex("priority","priority"),n.createIndex("status","status"),n.createIndex("days","days"),n.createIndex("carryOver","carryOver"),n.createIndex("createdDate","createdDate"),n.createIndex("lastModifiedDate","lastModifiedDate"),n.createIndex("startDate","startDate"),n.createIndex("endDate","endDate"),n.createIndex("isDeleted","isDeleted"),n.createIndex("isArchived","isArchived")}if(i.oldVersion===13){if(console.info("Upgrading from version 13."),!a.objectStoreNames.contains(o.Lists)){const n=a.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});n.createIndex("type","type"),n.createIndex("budget","budget")}a.objectStoreNames.contains(o.Tasks)||a.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"}).createIndex("amount","amount")}}})}repositories(){if(!this.indexRequest)throw new p;return{tasks:this.tasks||new Ve(this.indexRequest),cleanup:this.cleanup||new Qe(this.indexRequest),lists:this.lists||new Ye(this.indexRequest),reports:this.reports||new Je(this.indexRequest),settings:this.settings||new ze(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new G,await this.instance.start()),this.instance}async clear(e){this.indexRequest&&this.indexRequest.result.transaction([e],"readwrite").objectStore(e).clear()}async delete(){return new Promise((e,s)=>{this.indexRequest?.result.close();const r=indexedDB.deleteDatabase("personalPlanner");r.onerror=()=>{s(new p("Error deleting database."))},r.onsuccess=()=>{this.indexRequest=void 0,e(null)},r.onblocked=()=>{s(new p("Request is blocked"))}})}}const re={id:0,name:"",archive:!1,archiveFor:30,theme:"default"},ct=ge("appStore",{state:()=>({isMobileLandscape:!1,isMobilePortrait:!1,isTabletLandscape:!1,isTabletPortrait:!1,device:{[M.isTabletPortrait]:!1,[M.isTabletLandscape]:!1,[M.isMobilePortrait]:!1,[M.isMobileLandscape]:!1},settings:re,globalLoading:!1}),getters:{isTablet(){return this.device.isTabletLandscape||this.device.isTabletPortrait},isMobile(){return this.device.isMobileLandscape||this.device.isMobilePortrait}},actions:{setMediaMatch(t,e){this.device[t]=e},async getSettings(t=!1){!t&&this.settings.id!==0||(this.settings=await this.$api.service.getSettings())},async updateSettings(t){this.settings=await this.$api.service.updateSettings(t),this.getSettings(!0)},async deleteApp(){return this.settings=re,(await G.getInstance()).delete()},async addSettings(t){this.settings=await this.$api.service.addSettings(t)},setGlobalLoading(t){this.globalLoading=t}}}),lt=({app:t})=>({$api:t.config.globalProperties.$api});export{M as D,k as F,G as L,at as N,Ue as P,T,it as a,H as b,Xe as c,st as d,Y as e,N as f,v as g,nt as h,et as i,lt as j,ot as o,rt as p,tt as s,ct as u};
