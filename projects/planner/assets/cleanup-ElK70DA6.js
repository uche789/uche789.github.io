(function(){"use strict";var y=(n=>(n[n.Open=1]="Open",n[n.Progress=2]="Progress",n[n.Done=3]="Done",n))(y||{}),u=(n=>(n.list="list",n.dateRange="dateRange",n.tomorrow="tomorrow",n.today="today",n.upcoming="upcoming",n.habits="habits",n.archived="archived",n))(u||{});const o={Lists:"lists",Tasks:"tasks",Settings:"appSettings",Reports:"reports",TaskRecords:"taskRecords"};class C{constructor(e){this.db=e}async deleteList(e){await this.db.lists.remove(e),await this.db.tasks.removeTasksByListId(e)}async getList(e){return await this.db.lists.get(e)}async getAllList(e,s){return await this.db.lists.getAll({type:"valid",offset:e,limit:s})}async getTaskForList(e,s,t,r=!1){return await this.db.tasks.getAll({type:u.list,listId:e,offset:s,limit:t,sortByPriority:r})}async getHabits(e,s,t=!1){return await this.db.tasks.getAll({type:u.habits,offset:e,limit:s,sortByPriority:t})}async getTask(e){return await this.db.tasks.get(e)}async getTodaysList(e,s,t=!1){return await this.db.tasks.getAll({type:u.today,offset:e,limit:s,sortByPriority:t})}async getTomorrowsList(e,s,t=!1){return await this.db.tasks.getAll({type:u.tomorrow,offset:e,limit:s,sortByPriority:t})}async getUpcoming(e,s,t=!1){return await this.db.tasks.getAll({type:u.upcoming,offset:e,limit:s,sortByPriority:t})}async deleteTask(e){await this.db.tasks.remove(e)}async updateTask(e,s=!1){if(s){const t=await this.db.tasks.updateTaskRecord({id:e.statusRecordId,status:e.status||y.Open,taskId:e.id,timestamp:e.statusUpdatedAt});return await this.db.tasks.update({...e,statusRecordId:t.id,statusUpdatedAt:t.timestamp})}return await this.db.tasks.update(e)}async updateList(e){await this.db.lists.update(e),await this.db.tasks.updateAllTasksForList(e)}getRecentLists(){return this.db.lists.getAll({type:"recent"})}async addTask(e){return await this.db.tasks.add(e)}async addList(e){return await this.db.lists.add(e)}cleanOldRecords(){return Promise.all([this.db.cleanup.cleanupLists(),this.db.cleanup.cleanupTasks()])}async getSettings(){return await this.db.settings.get()}async updateSettings(e){const t={...await this.getSettings(),...e};return await this.db.settings.update(t)}async addSettings(e){return await this.db.settings.add(e)}}class l extends Error{}class N extends Error{}class B extends Error{}const T={RECORD:"RECORD",TASK:"TASK"};class I extends Error{constructor(e,s,t,r){super(s,t),this.key=e,this.data=r}}const A=60*60*24*1e3,p=()=>new Date().toISOString().split("T")[0],v=()=>new Date(Date.now()+A).toISOString().split("T")[0],L=(n,e)=>{const s=e?new Date(e).getTime():Date.now();return new Date(s+A*n).toISOString().split("T")[0]},M=(n,e={},s)=>(n=n instanceof Date?n:new Date(n),new Intl.DateTimeFormat("en-US",e).format(n)),j=(n,e)=>{const s=new Set;let t=n;for(;t<=e;){const r=M(t,{weekday:"short"}).toLowerCase();if(s.add(r),t=L(1,t),s.size===7)break}return s};class K{constructor(e){this.indexRequest=e}getAllCount(e="valid"){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").getAll();r.onerror=()=>{t(new l("Failed to retreive list count"))},r.onsuccess=()=>{const i=r.result;e==="valid"&&s(i.filter(a=>e==="valid"&&a.isDeleted!==!1&&a.endDate>=p()).length),e==="archived"&&s(i.filter(a=>e==="archived"&&a.isArchived&&!a.isDeleted).length)}})}getAll(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").openCursor(null,"prev");r.onerror=()=>{t(new Error("Failed to get lists"))};const i={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},a=e.offset||0,c=e.limit||50;let h=0,d=a>0,w=0;r.onsuccess=async g=>{const x=g.target?.result;if(x&&d){d=!1,x.advance(a+1);return}if(x&&!d){e.type==="recent"&&h===4&&s(i);const f=x.value;let m=(f.isArchived||f.endDate>=p())&&!f.isDeleted;m&&e.type==="archived"&&(m=f.isArchived),m=m&&(!e.getOnlyActive||e.getOnlyActive&&f.startDate>p()),m&&(h<c&&(i.data.push(f),h++),w++),x.continue()}else i.pagination.page=a?Math.ceil(w/a):1,i.pagination.total=w,i.pagination.itemsPerPage=c,i.pagination.totalPages=Math.ceil(w/c),s(i)}})}add(e){return new Promise((s,t)=>{const r=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),isArchived:!1,isDeleted:!1});(!r.endDate||!r.startDate||r.startDate>r.endDate)&&t(new N("Start and end dates are required and should be valid"));const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).add(r);i.onerror=()=>{t(new Error("Failed to get lists"))},i.onsuccess=()=>{s({...r,id:i.result})}})}async update(e){const s=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);return new Promise((t,r)=>{const i=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).put(s);i.onerror=()=>{r(new Error("Failed to update list"))},i.onsuccess=()=>{t(i.result)}})}get(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).get(e);r.onerror=()=>{t(new Error("Failed to get lists"))},r.onsuccess=()=>{s(r.result)}})}remove(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).delete(e);r.onerror=()=>{t(new Error("Failed to remove list"))},r.onsuccess=()=>{s(null)}})}}function O(n,e){const s=new Set,t=[];for(const r of n)s.add(r);for(const r of e)s.has(r)&&t.push(r);return t}const E=n=>n.status===y.Open&&n.carryOver&&n.startDate<p()||!!n.days.length&&(!n.endDate||!!n.endDate&&n.endDate>=p())||!n.days.length&&n.startDate>=p(),q={[u.habits]:n=>!!n.days.length,[u.archived]:n=>n.isArchived,[u.list]:(n,e)=>n.listId===e,[u.today]:n=>{const e=n.status===y.Open&&n.carryOver&&n.startDate<p();return!n.listId&&(e||n.startDate===p()&&!n.days.length||!!n.days.length&&!!O([...j(p(),p())],n.days).length)},[u.tomorrow]:n=>!n.listId&&(n.startDate===v()||!!n.days.length&&!!O([...j(v(),v())],n.days).length),[u.upcoming]:n=>!n.listId&&n.startDate>=L(2),[u.dateRange]:(n,e)=>!n.listId&&(n.startDate>=e.from||n.startDate<=e.to)};class U{constructor(e){this.indexRequest=e}get(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).get(e);r.onerror=()=>{t(new l("Failed to get task"))},r.onsuccess=()=>{s(r.result)}})}async add(e){const s=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:y.Open});if(s.listId){const t=await this.getListDates(s.listId);s.startDate=t.from,s.endDate=t.to}return new Promise((t,r)=>{s.startDate||(s.startDate=p());const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).add(s);i.onerror=()=>{r(new l("Failed to add new task"))},i.onsuccess=()=>{t({...s,id:i.result})}})}async update(e){const s=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);if(s.listId){const t=await this.getListDates(s.listId);s.startDate=t.from,s.endDate=t.to}return new Promise((t,r)=>{const i=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).put(s);i.onerror=()=>{r(new Error("Failed to update task"))},i.onsuccess=()=>{t({...s,id:i.result})}})}getListDates(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists]).objectStore(o.Lists).get(e);r.onerror=()=>{t(new Error("Failed to get list for task"))},r.onsuccess=()=>{const i=r.result;s({from:i.startDate,to:i.endDate})}})}remove(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).delete(e);r.onerror=()=>{t(new l("Failed to remove task"))},r.onsuccess=()=>{s(null)}})}async getAll(e){const s=e.sortByPriority?"priority":"createdDate",t=e.sortByPriority?"next":"prev",r=[],a=await new Promise((h,d)=>{const w=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index(s).openCursor(null,t);w.onerror=()=>{d(new l("Failed to get tasks"))};const g={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let x=0;const f=e.offset||0,m=e.limit||50;let R=0,S=f;w.onsuccess=H=>{const P=H.target?.result;if(P){const D=P.value;let b=!!D.listId||D.isArchived||E(D);b&&(e.type===u.dateRange?b=q.dateRange(D,e.dateRange||{from:"",to:""}):e.type===u.list?b=q.list(D,e.listId||0):b=q[e.type](D)),b=b&&(!e.incompleteOnly||e.incompleteOnly&&D.status!==y.Done),b&&S>0?(R++,S--,r.push(D.id)):b&&S===0&&(x<m&&(g.data.push(D),x++),r.push(D.id),R++),P.continue()}else g.pagination.page=f?Math.ceil(R/f):1,g.pagination.total=R,g.pagination.itemsPerPage=m,g.pagination.totalPages=Math.ceil(R/m),h(g)}}),c=await this.getAllTaskRecords(e.type,a.data,r.sort((h,d)=>h-d),e.activeList);return a.data=c.result,a.pagination.completed=c.completed,a}async getAllTaskRecords(e,s,t,r=!1){if(!s.length||![u.today,u.list].includes(e)||u.list===e&&!r)return{result:s,completed:0};const a=await new Promise((d,w)=>{const g=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("taskId").getAll(IDBKeyRange.upperBound(t[t.length-1]));g.onerror=()=>{w(new Error("Failed to add task record"))},g.onsuccess=()=>{d(g.result)}});let c=0;return a.forEach(d=>{d.status===y.Done&&t.includes(d.taskId)&&c++}),{result:s.map(d=>{let w;return e===u.today?w=a.find(g=>g.taskId===d.id&&g.timestamp===d.startDate):e===u.list&&(w=a.find(g=>g.taskId===d.id&&!!d.listId)),w?(d.status=w.status,d.statusUpdatedAt=w.timestamp):(d.status=y.Open,d.statusUpdatedAt=void 0,d.statusRecordId=void 0),d}),completed:c}}updateTaskRecord(e){if(!e.id)return delete e.id,e.timestamp=p(),new Promise((s,t)=>{try{const r=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).add(e);r.onerror=()=>{t(new Error("Failed to add task record"))},r.onsuccess=()=>{s({...e,id:r.result})}}catch(r){throw console.error(r),r}});if(!e.timestamp)throw new l("invalid timestamp");return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).put(e);r.onerror=()=>{t(new Error("Failed to update task record"))},r.onsuccess=()=>{s(e)}})}getAllByListId(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),i=[];r.onerror=()=>{t(new l(`Failed to tasks for id ${e}`))},r.onsuccess=a=>{const c=a.target.result;c?(c.value.listId===e&&i.push(c.value),c.continue()):s(i)}})}async removeTasksByListId(e){let s=!1;const t=[];try{const r=await this.getAllByListId(e);for(const i of r)try{await this.remove(i.id),t.push(i.id)}catch{s=!0}s&&new I(T.TASK,"Failed to remove some tasks from the list",{},t)}catch{}return t}updateAllTasksForList(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),i=[];r.onerror=()=>{t(new l("Failed to update tasks for list"))},r.onsuccess=a=>{const c=a.target.result;if(c){const h=c.value;if(h.listId===e.id){i.push(c.value);const d={};e.endDate&&(d.endDate=e.endDate),e.startDate&&(d.startDate=e.endDate),c.update({...h,...d})}c.continue()}else s(null)}})}}class V{constructor(e){this.indexRequest=e}add(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Reports],"readwrite").objectStore(o.Reports).add(e);r.onerror=()=>{if(r.error?.message.includes("constraint")||r.error?.message==="Key already exists in the object store."){t(new B(r.error?.message));return}t(new l("Failed to add new report"))},r.onsuccess=()=>{s(e)}})}async get(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Reports]).objectStore(o.Reports).get(e);r.onerror=()=>{t(new l("Failed to get report"))},r.onsuccess=()=>{s(r.result)}})}}class F{constructor(e){this.indexRequest=e,this.objectNames=o}objectNames}class $ extends F{get(){return new Promise((e,s)=>{const t=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();t.onerror=()=>{s(new l("Error retrieving settings"))},t.onsuccess=()=>{e(t.result[0])}})}add(e){return new Promise((s,t)=>{e.lastModifiedDate=Date.now();const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(e);r.onerror=()=>{t(new l("Error saving settings"))},r.onsuccess=()=>{s({...e,id:r.result})}})}update(e){return new Promise((s,t)=>{e.lastModifiedDate=Date.now();const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(e);r.onerror=()=>{t(new l("Error saving settings"))},r.onsuccess=()=>{s(e)}})}}class z extends F{async cleanupLists(){let e=!0,s=0;const t=await this.getAllInvalidLists();try{for(const r of t)try{s+=await this.cleanupTasks(r)}catch{e=!0}e&&new I(T.TASK,"Failed to remove some tasks from the list",{})}catch{}return e||await this.deleteLists(t),{deletedLists:t.length,deletedTasks:s}}deleteLists(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction(this.objectNames.Lists,"readwrite").objectStore(this.objectNames.Lists).delete(e);r.onerror=()=>{t(new l("Failed to clean up old list"))},r.onsuccess=()=>{s(r.result)}})}async cleanupTasks(e){const s=await this.getAllInvalidTasks(e);return new Promise((t,r)=>{const i=this.indexRequest.result.transaction(this.objectNames.Tasks,"readwrite").objectStore(this.objectNames.Tasks).delete(s);i.onerror=()=>{r(new l("Error retrieving settings"))},i.onsuccess=()=>{t(s.length)}})}getAllInvalidTasks(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).index("createdDate").openCursor();r.onerror=()=>{t(new Error("Failed to get invalid tasks"))};const i=[];r.onsuccess=a=>{const c=a.target?.result;if(c){const h=c.value;(e&&e===h.listId||!e&&!h.listId&&!E(h)&&!h.isArchived)&&i.push(h),c.continue()}else s(i.map(h=>h.id))}})}getAllInvalidLists(){return new Promise((e,s)=>{const t=this.indexRequest.result.transaction([o.Lists],"readonly").objectStore(o.Lists).index("createdDate").openCursor();t.onerror=()=>{s(new Error("Failed to get lists"))};const r=[];t.onsuccess=i=>{const a=i.target?.result;if(a){const c=a.value;(c.isDeleted||c.endDate<p()&&!c.isArchived)&&r.push(a.value),a.continue()}else e(r.map(c=>c.id))}})}}class k{tasks;lists;indexRequest;reports;cleanup;settings;static instance;async hasDatabase(){return new Promise((e,s)=>{if(!this.indexRequest){s(new l("Database does not exist"));return}try{const t=this.indexRequest.result.transaction([o.Settings]).objectStore(o.Settings).getAll();t.onerror=()=>{s(new l("Error retrieving settings"))},t.onsuccess=()=>{e(!!t.result.length)}}catch(t){if(t.message.includes("The database connection is closing")){e(!1);return}s(new l(t.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((e,s)=>{const t=indexedDB.open("personalPlanner",13);t.onerror=()=>{s(new l("Cannot use IndexDB"))},t.onsuccess=()=>{const r=t.result;r.onerror=i=>{s(new l(`Database error: ${i.target?.errorCode}`))},this.indexRequest=t,e(t)},t.onupgradeneeded=r=>{const i=t.result;if(!i.objectStoreNames.contains(o.Lists)){const a=i.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});a.createIndex("description","description"),a.createIndex("createdDate","createdDate"),a.createIndex("lastModifiedDate","lastModifiedDate"),a.createIndex("startDate","startDate"),a.createIndex("endDate","endDate"),a.createIndex("isDeleted","isDeleted"),a.createIndex("isArchived","isArchived")}if(!i.objectStoreNames.contains(o.TaskRecords)){const a=i.createObjectStore(o.TaskRecords,{autoIncrement:!0,keyPath:"id"});a.createIndex("taskId","taskId"),a.createIndex("status","status"),a.createIndex("timestamp","timestamp")}if(r.oldVersion,i.objectStoreNames.contains(o.Reports)||i.createObjectStore(o.Reports,{keyPath:"date"}).createIndex("count","count"),!i.objectStoreNames.contains(o.Settings)){const a=i.createObjectStore(o.Settings,{keyPath:"id",autoIncrement:!0});a.createIndex("archive","archive"),a.createIndex("archiveFor","archiveFor"),a.createIndex("image","image"),a.createIndex("name","name"),a.createIndex("lastModifiedDate","lastModifiedDate"),a.createIndex("theme","theme")}if(!i.objectStoreNames.contains(o.Tasks)){const a=i.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"});a.createIndex("listId","listId"),a.createIndex("description","description"),a.createIndex("note","note"),a.createIndex("startTime","startTime"),a.createIndex("endTime","endTime"),a.createIndex("priority","priority"),a.createIndex("status","status"),a.createIndex("days","days"),a.createIndex("carryOver","carryOver"),a.createIndex("createdDate","createdDate"),a.createIndex("lastModifiedDate","lastModifiedDate"),a.createIndex("startDate","startDate"),a.createIndex("endDate","endDate"),a.createIndex("isDeleted","isDeleted"),a.createIndex("isArchived","isArchived")}}})}repositories(){if(!this.indexRequest)throw new l;return{tasks:this.tasks||new U(this.indexRequest),cleanup:this.cleanup||new z(this.indexRequest),lists:this.lists||new K(this.indexRequest),reports:this.reports||new V(this.indexRequest),settings:this.settings||new $(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new k,await this.instance.start()),this.instance}async clear(e){this.indexRequest&&this.indexRequest.result.transaction([e],"readwrite").objectStore(e).clear()}async delete(){return new Promise((e,s)=>{this.indexRequest?.result.close();const t=indexedDB.deleteDatabase("personalPlanner");t.onerror=()=>{s(new l("Error deleting database."))},t.onsuccess=()=>{this.indexRequest=void 0,e(null)},t.onblocked=()=>{s(new l("Request is blocked"))}})}}onmessage=async function(n){console.info(n.data);const e=await k.getInstance();try{await new C(e.repositories()).cleanOldRecords(),this.postMessage("clean up completed")}catch{}}})();
