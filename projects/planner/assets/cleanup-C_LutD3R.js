(function(){"use strict";var y=(n=>(n[n.Open=1]="Open",n[n.Progress=2]="Progress",n[n.Done=3]="Done",n))(y||{}),u=(n=>(n.list="list",n.dateRange="dateRange",n.tomorrow="tomorrow",n.today="today",n.upcoming="upcoming",n.habits="habits",n.archived="archived",n))(u||{});const o={Lists:"lists",Tasks:"tasks",Settings:"appSettings",Reports:"reports",TaskRecords:"taskRecords"};class C{constructor(e){this.db=e}async deleteList(e){await this.db.lists.remove(e),await this.db.tasks.removeTasksByListId(e)}async getList(e){return await this.db.lists.get(e)}async getAllList(e,s){return await this.db.lists.getAll({type:"valid",offset:e,limit:s})}async getTaskForList(e,s,t,r=!1){const a=await this.db.tasks.getAll({type:u.list,listId:e,offset:s,limit:t,sortByPriority:r});return console.log(a),a}async getHabits(e,s,t=!1){return await this.db.tasks.getAll({type:u.habits,offset:e,limit:s,sortByPriority:t})}async getTask(e){return await this.db.tasks.get(e)}async getTodaysList(e,s,t=!1){return console.log("offset",e),await this.db.tasks.getAll({type:u.today,offset:e,limit:s,sortByPriority:t})}async getTomorrowsList(e,s,t=!1){return await this.db.tasks.getAll({type:u.tomorrow,offset:e,limit:s,sortByPriority:t})}async getUpcoming(e,s,t=!1){return await this.db.tasks.getAll({type:u.upcoming,offset:e,limit:s,sortByPriority:t})}async deleteTask(e){await this.db.tasks.remove(e)}async updateTask(e,s=!1){if(s){const t=await this.db.tasks.updateTaskRecord({id:e.statusRecordId,status:e.status||y.Open,taskId:e.id,timestamp:e.statusUpdatedAt});return await this.db.tasks.update({...e,statusRecordId:t.id,statusUpdatedAt:t.timestamp})}return await this.db.tasks.update(e)}async updateList(e){await this.db.lists.update(e),await this.db.tasks.updateAllTasksForList(e)}getRecentLists(){return this.db.lists.getAll({type:"recent"})}async addTask(e){return await this.db.tasks.add(e)}async addList(e){return await this.db.lists.add(e)}cleanOldRecords(){return Promise.all([this.db.cleanup.cleanupLists(),this.db.cleanup.cleanupTasks()])}async getSettings(){return await this.db.settings.get()}async updateSettings(e){const t={...await this.getSettings(),...e};return await this.db.settings.update(t)}async addSettings(e){return await this.db.settings.add(e)}}class l extends Error{}class N extends Error{}class B extends Error{}const T={RECORD:"RECORD",TASK:"TASK"};class I extends Error{constructor(e,s,t,r){super(s,t),this.key=e,this.data=r}}const A=60*60*24*1e3,p=()=>new Date().toISOString().split("T")[0],v=()=>new Date(Date.now()+A).toISOString().split("T")[0],L=(n,e)=>{const s=e?new Date(e).getTime():Date.now();return new Date(s+A*n).toISOString().split("T")[0]},M=(n,e={},s)=>(n=n instanceof Date?n:new Date(n),new Intl.DateTimeFormat("en-US",e).format(n)),j=(n,e)=>{const s=new Set;let t=n;for(;t<=e;){const r=M(t,{weekday:"short"}).toLowerCase();if(s.add(r),t=L(1,t),s.size===7)break}return s};class K{constructor(e){this.indexRequest=e}getAllCount(e="valid"){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").getAll();r.onerror=()=>{t(new l("Failed to retreive list count"))},r.onsuccess=()=>{const a=r.result;e==="valid"&&s(a.filter(i=>e==="valid"&&i.isDeleted!==!1&&i.endDate>=p()).length),e==="archived"&&s(a.filter(i=>e==="archived"&&i.isArchived&&!i.isDeleted).length)}})}getAll(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).index("createdDate").openCursor(null,"prev");r.onerror=()=>{t(new Error("Failed to get lists"))};const a={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}},i=e.offset||0,c=e.limit||50;let g=0,d=i>0,h=0;r.onsuccess=async w=>{const x=w.target?.result;if(x&&d){d=!1,x.advance(i+1);return}if(x&&!d){e.type==="recent"&&g===4&&s(a);const D=x.value;let m=(D.isArchived||D.endDate>=p())&&!D.isDeleted;m&&e.type==="archived"&&(m=D.isArchived),m=m&&(!e.getOnlyActive||e.getOnlyActive&&D.startDate>p()),m&&(g<c&&(a.data.push(D),g++),h++),x.continue()}else a.pagination.page=i?Math.ceil(h/i):1,a.pagination.total=h,a.pagination.itemsPerPage=c,a.pagination.totalPages=Math.ceil(h/c),s(a)}})}add(e){return new Promise((s,t)=>{const r=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),isArchived:!1,isDeleted:!1});(!r.endDate||!r.startDate||r.startDate>r.endDate)&&t(new N("Start and end dates are required and should be valid"));const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).add(r);a.onerror=()=>{t(new Error("Failed to get lists"))},a.onsuccess=()=>{s({...r,id:a.result})}})}async update(e){const s=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);return new Promise((t,r)=>{const a=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).put(s);a.onerror=()=>{r(new Error("Failed to update list"))},a.onsuccess=()=>{t(a.result)}})}get(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).get(e);r.onerror=()=>{t(new Error("Failed to get lists"))},r.onsuccess=()=>{s(r.result)}})}remove(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists],"readwrite").objectStore(o.Lists).delete(e);r.onerror=()=>{t(new Error("Failed to remove list"))},r.onsuccess=()=>{s(null)}})}}function O(n,e){const s=new Set,t=[];for(const r of n)s.add(r);for(const r of e)s.has(r)&&t.push(r);return t}const E=n=>n.status===y.Open&&n.carryOver&&n.startDate<p()||!!n.days.length&&(!n.endDate||!!n.endDate&&n.endDate>=p())||!n.days.length&&n.startDate>=p(),q={[u.habits]:n=>!!n.days.length,[u.archived]:n=>n.isArchived,[u.list]:(n,e)=>n.listId===e,[u.today]:n=>{const e=n.status===y.Open&&n.carryOver&&n.startDate<p();return!n.listId&&(e||n.startDate===p()||!!n.days.length&&!!O([...j(p(),p())],n.days).length)},[u.tomorrow]:n=>!n.listId&&(n.startDate===v()||!!n.days.length&&!!O([...j(v(),v())],n.days).length),[u.upcoming]:n=>!n.listId&&n.startDate>=L(2),[u.dateRange]:(n,e)=>!n.listId&&(n.startDate>=e.from||n.startDate<=e.to)};class U{constructor(e){this.indexRequest=e}get(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).get(e);r.onerror=()=>{t(new l("Failed to get task"))},r.onsuccess=()=>{s(r.result)}})}async add(e){const s=Object.assign({},e,{createdDate:Date.now(),lastModifiedDate:Date.now(),status:y.Open});if(s.listId){const t=await this.getListDates(s.listId);s.startDate=t.from,s.endDate=t.to}return new Promise((t,r)=>{s.startDate||(s.startDate=p());const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).add(s);a.onerror=()=>{r(new l("Failed to add new task"))},a.onsuccess=()=>{t({...s,id:a.result})}})}async update(e){const s=Object.assign({},await this.get(e.id),{lastModifiedDate:String(Date.now())},e);if(s.listId){const t=await this.getListDates(s.listId);s.startDate=t.from,s.endDate=t.to}return new Promise((t,r)=>{const a=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).put(s);a.onerror=()=>{r(new Error("Failed to update task"))},a.onsuccess=()=>{t({...s,id:a.result})}})}getListDates(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Lists]).objectStore(o.Lists).get(e);r.onerror=()=>{t(new Error("Failed to get list for task"))},r.onsuccess=()=>{const a=r.result;s({from:a.startDate,to:a.endDate})}})}remove(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).delete(e);r.onerror=()=>{t(new l("Failed to remove task"))},r.onsuccess=()=>{s(null)}})}async getAll(e){const s=e.sortByPriority?"priority":"createdDate",t=e.sortByPriority?"next":"prev",r=[],i=await new Promise((g,d)=>{const h=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index(s).openCursor(null,t);h.onerror=()=>{d(new l("Failed to get tasks"))};const w={data:[],pagination:{page:0,totalPages:0,itemsPerPage:0,total:0}};let x=0;const D=e.offset||0,m=e.limit||50;let R=0,S=D;h.onsuccess=H=>{const P=H.target?.result;if(P){const f=P.value;let b=!!f.listId||f.isArchived||E(f);b&&(e.type===u.dateRange?b=q.dateRange(f,e.dateRange||{from:"",to:""}):e.type===u.list?b=q.list(f,e.listId||0):b=q[e.type](f)),b=b&&(!e.incompleteOnly||e.incompleteOnly&&f.status!==y.Done),b&&S>0?(R++,S--,r.push(f.id)):b&&S===0&&(x<m&&(w.data.push(f),x++),r.push(f.id),R++),P.continue()}else w.pagination.page=D?Math.ceil(R/D):1,w.pagination.total=R,w.pagination.itemsPerPage=m,w.pagination.totalPages=Math.ceil(R/m),g(w)}}),c=await this.getAllTaskRecords(e.type,i.data,r.sort((g,d)=>g-d),e.activeList);return i.data=c.result,i.pagination.completed=c.completed,i}async getAllTaskRecords(e,s,t,r=!1){if(!s.length||![u.today,u.list].includes(e)||u.list===e&&!r)return{result:s,completed:0};const i=await new Promise((d,h)=>{const w=this.indexRequest.result.transaction([o.TaskRecords],"readonly").objectStore(o.TaskRecords).index("taskId").getAll(IDBKeyRange.upperBound(t[t.length-1]));w.onerror=()=>{h(new Error("Failed to add task record"))},w.onsuccess=()=>{d(w.result)}});let c=0;return i.forEach(d=>{d.status===y.Done&&t.includes(d.taskId)&&c++}),{result:s.map(d=>{const h=i.find(w=>w.taskId===d.id);return h&&(e===u.list||e===u.today&&h.timestamp===d.startDate)?(d.status=h.status,d.statusUpdatedAt=h.timestamp):(d.status=y.Open,d.statusUpdatedAt=void 0),d}),completed:c}}updateTaskRecord(e){if(!e.id)return delete e.id,e.timestamp=p(),new Promise((s,t)=>{try{const r=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).add(e);r.onerror=()=>{t(new Error("Failed to add task record"))},r.onsuccess=()=>{s({...e,id:r.result})}}catch(r){throw console.error(r),r}});if(!e.timestamp)throw new l("invalid timestamp");return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.TaskRecords],"readwrite").objectStore(o.TaskRecords).put(e);r.onerror=()=>{t(new Error("Failed to update task record"))},r.onsuccess=()=>{s(e)}})}getAllByListId(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),a=[];r.onerror=()=>{t(new l(`Failed to tasks for id ${e}`))},r.onsuccess=i=>{const c=i.target.result;c?(c.value.listId===e&&a.push(c.value),c.continue()):s(a)}})}async removeTasksByListId(e){let s=!1;const t=[];try{const r=await this.getAllByListId(e);for(const a of r)try{await this.remove(a.id),t.push(a.id)}catch{s=!0}s&&new I(T.TASK,"Failed to remove some tasks from the list",{},t)}catch{}return t}updateAllTasksForList(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readwrite").objectStore(o.Tasks).index("createdDate").openCursor(),a=[];r.onerror=()=>{t(new l("Failed to update tasks for list"))},r.onsuccess=i=>{const c=i.target.result;if(c){const g=c.value;if(g.listId===e.id){a.push(c.value);const d={};e.endDate&&(d.endDate=e.endDate),e.startDate&&(d.startDate=e.endDate),c.update({...g,...d})}c.continue()}else s(null)}})}}class V{constructor(e){this.indexRequest=e}add(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Reports],"readwrite").objectStore(o.Reports).add(e);r.onerror=()=>{if(r.error?.message.includes("constraint")||r.error?.message==="Key already exists in the object store."){t(new B(r.error?.message));return}t(new l("Failed to add new report"))},r.onsuccess=()=>{s(e)}})}async get(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Reports]).objectStore(o.Reports).get(e);r.onerror=()=>{t(new l("Failed to get report"))},r.onsuccess=()=>{s(r.result)}})}}class F{constructor(e){this.indexRequest=e,this.objectNames=o}objectNames}class $ extends F{get(){return new Promise((e,s)=>{const t=this.indexRequest.result.transaction(this.objectNames.Settings,"readonly").objectStore(this.objectNames.Settings).getAll();t.onerror=()=>{s(new l("Error retrieving settings"))},t.onsuccess=()=>{e(t.result[0])}})}add(e){return new Promise((s,t)=>{e.lastModifiedDate=Date.now();const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).add(e);r.onerror=()=>{t(new l("Error saving settings"))},r.onsuccess=()=>{s({...e,id:r.result})}})}update(e){return new Promise((s,t)=>{e.lastModifiedDate=Date.now();const r=this.indexRequest.result.transaction(this.objectNames.Settings,"readwrite").objectStore(this.objectNames.Settings).put(e);r.onerror=()=>{t(new l("Error saving settings"))},r.onsuccess=()=>{s(e)}})}}class z extends F{async cleanupLists(){let e=!0,s=0;const t=await this.getAllInvalidLists();try{for(const r of t)try{s+=await this.cleanupTasks(r)}catch{e=!0}e&&new I(T.TASK,"Failed to remove some tasks from the list",{})}catch{}return e||await this.deleteLists(t),{deletedLists:t.length,deletedTasks:s}}deleteLists(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction(this.objectNames.Lists,"readwrite").objectStore(this.objectNames.Lists).delete(e);r.onerror=()=>{t(new l("Failed to clean up old list"))},r.onsuccess=()=>{s(r.result)}})}async cleanupTasks(e){const s=await this.getAllInvalidTasks(e);return new Promise((t,r)=>{const a=this.indexRequest.result.transaction(this.objectNames.Tasks,"readwrite").objectStore(this.objectNames.Tasks).delete(s);a.onerror=()=>{r(new l("Error retrieving settings"))},a.onsuccess=()=>{t(s.length)}})}getAllInvalidTasks(e){return new Promise((s,t)=>{const r=this.indexRequest.result.transaction([o.Tasks],"readonly").objectStore(o.Tasks).index("createdDate").openCursor();r.onerror=()=>{t(new Error("Failed to get invalid tasks"))};const a=[];r.onsuccess=i=>{const c=i.target?.result;if(c){const g=c.value;(e&&e===g.listId||!e&&!g.listId&&!E(g)&&!g.isArchived)&&a.push(g),c.continue()}else s(a.map(g=>g.id))}})}getAllInvalidLists(){return new Promise((e,s)=>{const t=this.indexRequest.result.transaction([o.Lists],"readonly").objectStore(o.Lists).index("createdDate").openCursor();t.onerror=()=>{s(new Error("Failed to get lists"))};const r=[];t.onsuccess=a=>{const i=a.target?.result;if(i){const c=i.value;(c.isDeleted||c.endDate<p()&&!c.isArchived)&&r.push(i.value),i.continue()}else e(r.map(c=>c.id))}})}}class k{tasks;lists;indexRequest;reports;cleanup;settings;static instance;async hasDatabase(){return new Promise((e,s)=>{if(!this.indexRequest){s(new l("Database does not exist"));return}try{const t=this.indexRequest.result.transaction([o.Settings]).objectStore(o.Settings).getAll();t.onerror=()=>{s(new l("Error retrieving settings"))},t.onsuccess=()=>{e(!!t.result.length)}}catch(t){if(t.message.includes("The database connection is closing")){e(!1);return}s(new l(t.message))}})}start(){return this.indexRequest?Promise.resolve(this.indexRequest):new Promise((e,s)=>{const t=indexedDB.open("personalPlanner",13);t.onerror=()=>{s(new l("Cannot use IndexDB"))},t.onsuccess=()=>{const r=t.result;r.onerror=a=>{s(new l(`Database error: ${a.target?.errorCode}`))},this.indexRequest=t,e(t)},t.onupgradeneeded=r=>{const a=t.result;if(!a.objectStoreNames.contains(o.Lists)){const i=a.createObjectStore(o.Lists,{autoIncrement:!0,keyPath:"id"});i.createIndex("description","description"),i.createIndex("createdDate","createdDate"),i.createIndex("lastModifiedDate","lastModifiedDate"),i.createIndex("startDate","startDate"),i.createIndex("endDate","endDate"),i.createIndex("isDeleted","isDeleted"),i.createIndex("isArchived","isArchived")}if(!a.objectStoreNames.contains(o.TaskRecords)){const i=a.createObjectStore(o.TaskRecords,{autoIncrement:!0,keyPath:"id"});i.createIndex("taskId","taskId"),i.createIndex("status","status"),i.createIndex("timestamp","timestamp")}if(r.oldVersion,a.objectStoreNames.contains(o.Reports)||a.createObjectStore(o.Reports,{keyPath:"date"}).createIndex("count","count"),!a.objectStoreNames.contains(o.Settings)){const i=a.createObjectStore(o.Settings,{keyPath:"id",autoIncrement:!0});i.createIndex("archive","archive"),i.createIndex("archiveFor","archiveFor"),i.createIndex("image","image"),i.createIndex("name","name"),i.createIndex("lastModifiedDate","lastModifiedDate")}if(!a.objectStoreNames.contains(o.Tasks)){const i=a.createObjectStore(o.Tasks,{autoIncrement:!0,keyPath:"id"});i.createIndex("listId","listId"),i.createIndex("description","description"),i.createIndex("note","note"),i.createIndex("startTime","startTime"),i.createIndex("endTime","endTime"),i.createIndex("priority","priority"),i.createIndex("status","status"),i.createIndex("days","days"),i.createIndex("carryOver","carryOver"),i.createIndex("createdDate","createdDate"),i.createIndex("lastModifiedDate","lastModifiedDate"),i.createIndex("startDate","startDate"),i.createIndex("endDate","endDate"),i.createIndex("isDeleted","isDeleted"),i.createIndex("isArchived","isArchived")}}})}repositories(){if(!this.indexRequest)throw new l;return{tasks:this.tasks||new U(this.indexRequest),cleanup:this.cleanup||new z(this.indexRequest),lists:this.lists||new K(this.indexRequest),reports:this.reports||new V(this.indexRequest),settings:this.settings||new $(this.indexRequest)}}static async getInstance(){return this.instance||(this.instance=new k,await this.instance.start()),this.instance}async clear(e){this.indexRequest&&this.indexRequest.result.transaction([e],"readwrite").objectStore(e).clear()}async delete(){return new Promise((e,s)=>{this.indexRequest?.result.close();const t=indexedDB.deleteDatabase("personalPlanner");t.onerror=()=>{s(new l("Error deleting database."))},t.onsuccess=()=>{this.indexRequest=void 0,e(null)},t.onblocked=()=>{s(new l("Request is blocked"))}})}}onmessage=async function(n){console.info(n.data);const e=await k.getInstance();try{await new C(e.repositories()).cleanOldRecords(),this.postMessage("clean up completed")}catch{}}})();
