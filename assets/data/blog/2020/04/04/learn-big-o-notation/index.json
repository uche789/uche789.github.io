{"hash":"70f07237fcccc9d3767dd3a92940081e192ee011","data":{"post":{"id":"cd7214ebbd9b9d0f030e35f165c5c24f","title":"Learning Big O notation as a Javascript developer","tags":"performance javascript big-o-notation data-structures","date":"2020-04-04T00:00:00.000Z","content":"<p>We all know that while there are multiple solutions to a given problem, some solutions are better than others and could have a significant impact on the performance of your software. It's easy to overlook performance as long as the desired functionality is achieved and in a lot of small to mid-scale projects, performance can be negligible. However, when building large-scale applications or software that processes large amounts of data, the code handling the processing should be efficient and performant.</p>\n<p>This is why Big O notation is necessary.</p>\n<p>Big O notation is a mathematical notation that denotes the efficiency of an algorithm and specifically takes into account the worst-case scenario. Big-O consists of time and space complexity.</p>\n<p><strong>Time complexity</strong> describes the execution time of an algorithm and <strong>Space complexity</strong> describes the space it requires.</p>\n<p>Big O notations are grouped together with data structures as a means to organize, manage, and store data in a format that enables efficient access and modification. Data structures are used in almost every program or software system and very common examples include arrays, linked lists, and graphs. For example, the DOM (Document Object Model) of an HTML document is a <a href=\"https://en.wikipedia.org/wiki/Tree_(data_structure)\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tree structure</a> consisting of nodes.</p>\n<p>Have you ever wondered what are the time and space complexity of javascript native functions such as <code>indexOf</code>, <code>find</code> and <code>includes</code> and how to use them efficiently?</p>\n<p>Although javascript built-in functions are quite performant and should definitely be used in place of custom solutions, they can yield terrible performance if not used correctly. For example, using <code>indexOf</code> inside a <code>for</code> loop has a time complexity of o(n^2) which is very inefficient with large sets of data.</p>\n<p>It takes time to understand and consciously incorporate Big O notation as part of your regular development process. However here are a few tips to help you get started:</p>\n<ul>\n<li><strong>Avoid nested loops:</strong> nested loops can a negative impact on the performance of your code when working with large data sets. It's better to work with multiple <code>for</code> loops that are not nested as the time complexity will always be o(kn) = o(n), where k is the number of loops.</li>\n<li><strong>Use Built-in functions:</strong> it is always safe to use built-in functions such as <code>map</code>, <code>filter</code>, <code>reduce</code>, <code>find</code>, <code>forEach</code>, and <code>sort</code> as they have been optimized by the JavaScript engines that run them. Optionally, <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Lodash</a> utility library provides very useful functions for common programming tasks.</li>\n<li><strong>Opt for object instead of array of objects:</strong> sometimes, it's easier to work with objects instead of arrays if you can and want to associate a key or id with a data set for easy access. Using the native functions <code>Object.keys</code> and <code>Object.values</code> facilitates iterating over object properties and values. </li>\n<li><strong>Learn how to use sorting and search algorithms:</strong> I'm sure you've already heard about <em>binary search</em>, <em>merge sort</em>, and <em>quicksort</em>. Although a lot of built-in functions and libraries use these algorithms internally and in most cases you might not need to write a sorting algorithm, it is important to have a fundamental understanding of sorting and search algorithms in the event that you may have to work with a complex data structure.</li>\n<li><strong>Use variables efficiently:</strong> a variable is the name of a storage location. Variables should be declared only when need and ideally, as local as possible. Keep in mind that objects that are still referenced by your application are not cleaned up by the garbage collector.</li>\n<li><strong>Use a javascript linter:</strong> javascript linters are beneficial in optimizing your code and improve quality. JSLint and ESLint are two very popular linters. There are also may good styleguide to use when configuring your linter. I always recommend the <a href=\"https://github.com/airbnb/javascript\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">airbnb styleguide</a>.</li>\n<li><strong>Read open-source coded and practice problem solving:</strong> reading open-source code provides a wealth of information and websites such as Codewars can be beneficial improve your problem-solving skills. Keep in mind you'll only get better the more code you write. </li>\n</ul>\n<p>Should you consider the time and space complexity in all of your projects? <strong><em>Absolutely!</em></strong> It doesn't matter the size of your application. Understanding Big O notation, code optimization, and efficient resource usage is an essential skill for all developers wanting to build scalable and performant applications with minimal effort.</p>\n<h2>Resources</h2>\n<ul>\n<li><a href=\"https://www.bigocheatsheet.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Big-O Cheat Sheet</a></li>\n<li><a href=\"https://adrianmejia.com/how-you-can-change-the-world-learning-data-structures-algorithms-free-online-course-tutorial/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tutorial series: Learning Data Structures and Algorithms (DSA) for Beginners</a></li>\n<li><a href=\"https://dev.to/b0nbon1/understanding-big-o-notation-with-javascript-25mc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Understanding Big-O Notation With JavaScript</a></li>\n<li><a href=\"https://www.interviewcake.com/article/python/big-o-notation-time-and-space-complexity?\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The idea behind big O notation</a></li>\n<li><a href=\"https://www.codewars.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Codewars</a></li>\n<li><a href=\"https://leetcode.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Leetcode</a></li>\n<li><em><strong>High Performance JavaScript (Build Faster Web Application Interfaces)</strong></em> by Nicholas C. Zakas</li>\n</ul>\n","timeToRead":3}},"context":{}}